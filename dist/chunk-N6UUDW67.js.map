{"version":3,"sources":["../src/resources/AsyncLogger.ts"],"sourcesContent":["import type { Hamming } from \"../index\";\nimport { LogMessage } from \"../types/asyncLogger\";\nimport { ManualResetEvent } from \"./ManualResetEvent\";\n\nconst LOG_BATCH_SIZE = 512;\n\nexport class AsyncLogger {\n  private client: Hamming;\n\n  private queue: LogMessage[];\n  private stopEvent: boolean;\n  private queueNotEmptyEvent: ManualResetEvent;\n\n  constructor(client: Hamming) {\n    this.client = client;\n\n    this.queue = [];\n    this.queue = [];\n    this.stopEvent = false;\n    this.queueNotEmptyEvent = new ManualResetEvent();\n  }\n\n  log(message: LogMessage): void {\n    this.queue.push(message);\n    this.queueNotEmptyEvent.set();\n  }\n\n  async start(): Promise<void> {\n    while (!this.stopEvent) {\n      await this.queueNotEmptyEvent.wait();\n      if (!this.stopEvent) {\n        await this._process_queue();\n      }\n    }\n  }\n\n  stop(): void {\n    console.log(\"Waiting for logger thread to exit..\");\n    this.stopEvent = true;\n  }\n\n  private _drain_queue(): LogMessage[] {\n    const drained_msgs: LogMessage[] = [];\n    while (this.queue.length > 0 && drained_msgs.length < LOG_BATCH_SIZE) {\n      const msg = this.queue.shift();\n      if (msg !== undefined) {\n        drained_msgs.push(msg);\n      }\n    }\n    return drained_msgs;\n  }\n\n  private async _process_queue(): Promise<void> {\n    const msgs_to_process: LogMessage[] = this._drain_queue();\n\n    await this._publish(msgs_to_process);\n\n    if (this.queue.length > 0) {\n      this.queueNotEmptyEvent.set();\n    } else {\n      this.queueNotEmptyEvent.reset();\n    }\n  }\n\n  private async _publish(msgs: LogMessage[]): Promise<void> {\n    console.log(`Publishing ${msgs.length} messages..`);\n    console.log(`Messages: ${JSON.stringify(msgs)}`);\n    try {\n      await this.client.fetch(\"/logs\", {\n        method: \"POST\",\n        body: JSON.stringify({\n          logs: msgs.map((msg) => ({\n            ...msg,\n            payload: {\n              ...msg.payload,\n              session_id: msg.payload?.sessionId,\n              seq_id: msg.payload?.seqId,\n              parent_seq_id: msg.payload?.parentSeqId,\n            },\n          })),\n        }),\n      });\n      console.log(`Published ${msgs.length} messages!`);\n    } catch (e) {\n      console.error(`Failed to publish messages: ${e}`);\n    }\n  }\n}\n"],"mappings":"gFAIA,IAAMA,EAAiB,IAEVC,EAAN,KAAkB,CAOvB,YAAYC,EAAiB,CAN7BC,EAAA,KAAQ,UAERA,EAAA,KAAQ,SACRA,EAAA,KAAQ,aACRA,EAAA,KAAQ,sBAGN,KAAK,OAASD,EAEd,KAAK,MAAQ,CAAC,EACd,KAAK,MAAQ,CAAC,EACd,KAAK,UAAY,GACjB,KAAK,mBAAqB,IAAIE,CAChC,CAEA,IAAIC,EAA2B,CAC7B,KAAK,MAAM,KAAKA,CAAO,EACvB,KAAK,mBAAmB,IAAI,CAC9B,CAEA,MAAM,OAAuB,CAC3B,KAAO,CAAC,KAAK,WACX,MAAM,KAAK,mBAAmB,KAAK,EAC9B,KAAK,WACR,MAAM,KAAK,eAAe,CAGhC,CAEA,MAAa,CACX,QAAQ,IAAI,qCAAqC,EACjD,KAAK,UAAY,EACnB,CAEQ,cAA6B,CACnC,IAAMC,EAA6B,CAAC,EACpC,KAAO,KAAK,MAAM,OAAS,GAAKA,EAAa,OAASN,GAAgB,CACpE,IAAMO,EAAM,KAAK,MAAM,MAAM,EACzBA,IAAQ,QACVD,EAAa,KAAKC,CAAG,CAEzB,CACA,OAAOD,CACT,CAEA,MAAc,gBAAgC,CAC5C,IAAME,EAAgC,KAAK,aAAa,EAExD,MAAM,KAAK,SAASA,CAAe,EAE/B,KAAK,MAAM,OAAS,EACtB,KAAK,mBAAmB,IAAI,EAE5B,KAAK,mBAAmB,MAAM,CAElC,CAEA,MAAc,SAASC,EAAmC,CACxD,QAAQ,IAAI,cAAcA,EAAK,MAAM,aAAa,EAClD,QAAQ,IAAI,aAAa,KAAK,UAAUA,CAAI,CAAC,EAAE,EAC/C,GAAI,CACF,MAAM,KAAK,OAAO,MAAM,QAAS,CAC/B,OAAQ,OACR,KAAM,KAAK,UAAU,CACnB,KAAMA,EAAK,IAAKF,IAAS,CACvB,GAAGA,EACH,QAAS,CACP,GAAGA,EAAI,QACP,WAAYA,EAAI,SAAS,UACzB,OAAQA,EAAI,SAAS,MACrB,cAAeA,EAAI,SAAS,WAC9B,CACF,EAAE,CACJ,CAAC,CACH,CAAC,EACD,QAAQ,IAAI,aAAaE,EAAK,MAAM,YAAY,CAClD,OAASC,EAAG,CACV,QAAQ,MAAM,+BAA+BA,CAAC,EAAE,CAClD,CACF,CACF","names":["LOG_BATCH_SIZE","AsyncLogger","client","__publicField","ManualResetEvent","message","drained_msgs","msg","msgs_to_process","msgs","e"]}