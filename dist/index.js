import{a as w}from"./chunk-LBDEHSKQ.js";import"./chunk-TZ55H3QO.js";import{a as T}from"./chunk-3QRTNJLL.js";import{a as o}from"./chunk-GQSCBKA6.js";var N=(a=>(a.CREATED="CREATED",a.RUNNING="RUNNING",a.SCORING="SCORING",a.SCORING_FAILED="SCORING_FAILED",a.FINISHED="FINISHED",a.FAILED="FAILED",a))(N||{}),I=class{constructor(t){o(this,"client");this.client=t}async start(t,e){let r=(await(await this.client.fetch(`/experiments/${t.id}/items`,{method:"POST",body:JSON.stringify({datasetItemId:e.id,output:{},metrics:{}})})).json()).item,a=Date.now();return{item:r,startTs:a}}async end(t,e){let{item:n,startTs:i}=t,r=Date.now()-i;await this.client.tracing._flush(n.id),await this.client.fetch(`/experiments/${n.experimentId}/items/${n.id}`,{method:"PATCH",body:JSON.stringify({output:e,metrics:{durationMs:r}})})}},f=class{constructor(t){o(this,"client");o(this,"items");this.client=t,this.items=new I(this.client)}async run(t,e){let{dataset:n}=t,i=await this.client.datasets.load(n),{name:r=this.generateName(i.name),scoring:a=O,metadata:g={}}=t,s=await this.start(r,n,a,g),x=`${new URL(this.client.baseURL).origin}/experiments/${s.id}`;try{if(t.parallel){let c=async d=>{let l=await this.items.start(s,d),D={tracing:new u(this.client.tracing,l.item.id)},R=await e(d.input,D);await this.items.end(l,R)},p=typeof t.parallel=="number"?t.parallel:void 0;await T(i.items,c,p)}else for(let c of i.items){let p=await this.items.start(s,c),d={tracing:new u(this.client.tracing,p.item.id)},l=await e(c.input,d);await this.items.end(p,l)}}catch(c){throw await this.end(s,"FAILED"),c}finally{await this.end(s),console.log("See experiment results at:",x)}return{experimentUrl:x}}async start(t,e,n,i){return(await(await this.client.fetch("/experiments",{method:"POST",body:JSON.stringify({name:t,dataset:e,status:"RUNNING",scoring:n,metadata:i})})).json()).experiment}async end(t,e="FINISHED"){await this.client.fetch(`/experiments/${t.id}`,{method:"PATCH",body:JSON.stringify({status:e})})}generateName(t){return`Experiment for ${t} - ${new Date().toLocaleString()}`}},b=(s=>(s.AccuracyAI="accuracy_ai",s.FactsCompare="facts_compare",s.ContextRecall="context_recall",s.ContextPrecision="context_precision",s.Hallucination="hallucination",s.StringDiff="string_diff",s.Refusal="refusal",s.SqlAst="sql_ast",s))(b||{}),O=["string_diff"],y=class{constructor(t){o(this,"client");this.client=t}async load(t){let e=await this.client.fetch(`/datasets/${t}`,{method:"GET"}),n;try{n=await e.json()}catch(i){throw new Error(`Failed to parse dataset response as JSON for dataset ID: ${t}: ${i}`)}return n.dataset}async list(){return(await(await this.client.fetch("/datasets")).json()).datasets}async create(t){let{name:e,description:n,items:i}=t;return(await(await this.client.fetch("/datasets",{method:"POST",body:JSON.stringify({name:e,description:n,items:i})})).json()).dataset}},v=class{constructor(t){o(this,"client");o(this,"collected",{});o(this,"currentLocalTraceId",0);this.client=t}nextTraceId(){return this.currentLocalTraceId++}async _flush(t){let e=this.collected[t]??[];delete this.collected[t];let n={id:this.nextTraceId(),experimentItemId:t,event:{kind:"root"}},i=[n];for(let r of e)i.push({id:this.nextTraceId(),experimentItemId:t,parentId:n.id,event:r});await this.client.fetch("/traces",{method:"POST",body:JSON.stringify({traces:i})})}_generationEvent(t){return{kind:"llm",...t}}_retrievalEvent(t){let e=a=>typeof a=="string",n=t.results?.every(e),i=a=>typeof a=="string"?{pageContent:a,metadata:{}}:a,r=n?t.results?.map(i):t.results;return{kind:"vector",...t,results:r}}log(t,e,n){let{event:i,tracingCtx:r}=(()=>{if(typeof t=="string"){let s=t,h=e;return{event:{[s]:h},tracingCtx:n}}else return{event:t,tracingCtx:e}})(),a=r?.experiment?.itemId;if(!a)throw new Error("Experiment item ID not found, use the new API 'ctx.tracing'.");this.collected[a]||(this.collected[a]=[]),this.collected[a].push(i)}logGeneration(t,e){this.log(this._generationEvent(t),e)}logRetrieval(t,e){this.log(this._retrievalEvent(t),e)}},u=class{constructor(t,e){o(this,"wrapped");o(this,"ctx");this.wrapped=t,this.ctx={experiment:{itemId:e}}}logGeneration(t){this.wrapped.logGeneration(t,this.ctx)}logRetrieval(t){this.wrapped.logRetrieval(t,this.ctx)}log(t,e){typeof t=="string"?this.wrapped.log(t,e,this.ctx):this.wrapped.log(t,this.ctx)}},C=["apiKey","baseURL"],E=class extends w{constructor(e){let n=Object.keys(e).filter(i=>!C.includes(i));n.length>0&&console.warn(`WARNING: Unexpected config keys found: ${n.join(", ")}. Valid config keys are: ${C.join(", ")}. The unexpected keys will be ignored.`);super({apiKey:e.apiKey,baseURL:e.baseURL??"https://app.hamming.ai/api/rest"});o(this,"experiments",new f(this));o(this,"datasets",new y(this));o(this,"tracing",new v(this))}};export{O as DefaultScoreTypes,N as ExperimentStatus,E as Hamming,b as ScoreType};
//# sourceMappingURL=index.js.map