var f=Object.defineProperty;var x=(r,t,e)=>t in r?f(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e;var i=(r,t,e)=>(x(r,typeof t!="symbol"?t+"":t,e),e);var D=(n=>(n.CREATED="CREATED",n.RUNNING="RUNNING",n.SCORING="SCORING",n.SCORING_FAILED="SCORING_FAILED",n.FINISHED="FINISHED",n.FAILED="FAILED",n))(D||{}),p=class{constructor(t){i(this,"client");this.client=t}async start(t,e){let c=(await(await this.client.fetch(`/experiments/${t.id}/items`,{method:"POST",body:JSON.stringify({datasetItemId:e.id,output:{},metrics:{}})})).json()).item,n=Date.now();return{item:c,startTs:n}}async end(t,e){let{item:a,startTs:s}=t,c=Date.now()-s;await this.client.fetch(`/experiments/${a.experimentId}/items/${a.id}`,{method:"PATCH",body:JSON.stringify({output:e,metrics:{durationMs:c}})}),await this.client.tracing._flush(a.id)}},u=class{constructor(t){i(this,"client");i(this,"items");this.client=t,this.items=new p(this.client)}async run(t,e){let{dataset:a}=t,s=await this.client.datasets.load(a),{name:c=this.generateName(s.name),scoring:n=v}=t,o=await this.start(c,a,n);try{for(let m of s.items){let I=await this.items.start(o,m),y=await e(m.input);await this.items.end(I,y)}}catch(m){throw await this.end(o,"FAILED"),m}finally{await this.end(o)}}async start(t,e,a){return(await(await this.client.fetch("/experiments",{method:"POST",body:JSON.stringify({name:t,dataset:e,status:"RUNNING",scoring:a})})).json()).experiment}async end(t,e="FINISHED"){await this.client.fetch(`/experiments/${t.id}`,{method:"PATCH",body:JSON.stringify({status:e})})}generateName(t){return`Experiment for ${t} - ${new Date().toLocaleString()}`}},E=(o=>(o.AccuracyAI="accuracy_ai",o.AccuracyHuman="accuracy_human",o.FactsCompare="facts_compare",o.ContextRecall="context_recall",o.ContextPrecision="context_precision",o.Hallucination="hallucination",o.StringDiff="string_diff",o))(E||{}),v=["string_diff"],d=class{constructor(t){i(this,"client");this.client=t}async load(t){return(await(await this.client.fetch(`/datasets/${t}`)).json()).dataset}async list(){return(await(await this.client.fetch("/datasets")).json()).datasets}async create(t){let{name:e,description:a,items:s}=t;return(await(await this.client.fetch("/datasets",{method:"POST",body:JSON.stringify({name:e,description:a,items:s})})).json()).dataset}},l=class{constructor(t){i(this,"apiKey");i(this,"baseURL");this.apiKey=t.apiKey,this.baseURL=this.sanitize_base_url(t.baseURL)}sanitize_base_url(t){return t=t.trim(),t.endsWith("/")?t.slice(0,-1):t}fetch(t,e){return fetch(this.baseURL+t,{...e,headers:{...e?.headers,authorization:`Bearer ${this.apiKey}`,"content-type":"application/json"}})}},h=class{constructor(t){i(this,"client");i(this,"collected",[]);i(this,"currentLocalTraceId",0);this.client=t}nextTraceId(){return this.currentLocalTraceId++}async _flush(t){let e=this.collected;this.collected=[];let a={id:this.nextTraceId(),experimentItemId:t,event:{kind:"root"}},s=[a];for(let c of e)s.push({id:this.nextTraceId(),experimentItemId:t,parentId:a.id,event:c});await this.client.fetch("/traces",{method:"POST",body:JSON.stringify({traces:s})})}LLMEvent(t){return{kind:"llm",...t}}VectorSearchEvent(t){let e=n=>typeof n=="string",a=t.results?.every(e),s=n=>typeof n=="string"?{pageContent:n,metadata:{}}:n,c=a?t.results?.map(s):t.results;return{kind:"vector",...t,results:c}}log(t,e){typeof t=="string"?this.collected.push({[t]:e}):this.collected.push(t)}},g=class extends l{constructor(e){super({apiKey:e.apiKey,baseURL:e.baseURL});i(this,"experiments",new u(this));i(this,"datasets",new d(this));i(this,"tracing",new h(this))}};export{v as DefaultScoreTypes,D as ExperimentStatus,g as Hamming,E as ScoreType};
//# sourceMappingURL=index.js.map