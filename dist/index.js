var f=Object.defineProperty;var x=(i,t,e)=>t in i?f(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e;var a=(i,t,e)=>(x(i,typeof t!="symbol"?t+"":t,e),e);var v=(s=>(s.CREATED="CREATED",s.RUNNING="RUNNING",s.SCORING="SCORING",s.SCORING_FAILED="SCORING_FAILED",s.FINISHED="FINISHED",s.FAILED="FAILED",s))(v||{}),p=class{constructor(t){a(this,"client");this.client=t}async start(t,e){let o=(await(await this.client.fetch(`/experiments/${t.id}/items`,{method:"POST",body:JSON.stringify({datasetItemId:e.id,output:{},metrics:{}})})).json()).item,s=Date.now();return{item:o,startTs:s}}async end(t,e){let{item:n,startTs:r}=t,o=Date.now()-r;await this.client.fetch(`/experiments/${n.experimentId}/items/${n.id}`,{method:"PATCH",body:JSON.stringify({output:e,metrics:{durationMs:o}})}),await this.client.tracing._flush(n.id)}},d=class{constructor(t){a(this,"client");a(this,"items");this.client=t,this.items=new p(this.client)}async run(t,e){let{dataset:n}=t,r=await this.client.datasets.load(n),{name:o=this.generateName(r.name),scoring:s=E}=t,c=await this.start(o,n,s);try{for(let m of r.items){let y=await this.items.start(c,m),I=await e(m.input);await this.items.end(y,I)}}catch(m){throw await this.end(c,"FAILED"),m}finally{await this.end(c)}}async start(t,e,n){return(await(await this.client.fetch("/experiments",{method:"POST",body:JSON.stringify({name:t,dataset:e,status:"RUNNING",scoring:n})})).json()).experiment}async end(t,e="FINISHED"){await this.client.fetch(`/experiments/${t.id}`,{method:"PATCH",body:JSON.stringify({status:e})})}generateName(t){return`Experiment for ${t} - ${new Date().toLocaleString()}`}},b=(c=>(c.AccuracyAI="accuracy_ai",c.AccuracyHuman="accuracy_human",c.FactsCompare="facts_compare",c.ContextRecall="context_recall",c.ContextPrecision="context_precision",c.Hallucination="hallucination",c.StringDiff="string_diff",c))(b||{}),E=["string_diff"],u=class{constructor(t){a(this,"client");this.client=t}async load(t){return(await(await this.client.fetch(`/datasets/${t}`)).json()).dataset}async list(){return(await(await this.client.fetch("/datasets")).json()).datasets}async create(t){let{name:e,description:n,items:r}=t;return(await(await this.client.fetch("/datasets",{method:"POST",body:JSON.stringify({name:e,description:n,items:r})})).json()).dataset}},l=class{constructor(t){a(this,"apiKey");a(this,"baseURL");a(this,"verbose");this.apiKey=t.apiKey,this.baseURL=this.sanitize_base_url(t.baseURL),this.verbose=t.verbose??!1}sanitize_base_url(t){return t=t.trim(),t.endsWith("/")?t.slice(0,-1):t}fetch(t,e){return fetch(this.baseURL+t,{...e,headers:{...e?.headers,authorization:`Bearer ${this.apiKey}`,"content-type":"application/json"}})}},h=class{constructor(t){a(this,"client");a(this,"collected",[]);a(this,"currentLocalTraceId",0);this.client=t}nextTraceId(){return this.currentLocalTraceId++}async _flush(t){let e=this.collected;this.collected=[];let n={id:this.nextTraceId(),experimentItemId:t,event:{kind:"root"}},r=[n];for(let o of e)r.push({id:this.nextTraceId(),experimentItemId:t,parentId:n.id,event:o});await this.client.fetch("/traces",{method:"POST",body:JSON.stringify({traces:r})})}LLMEvent(t){return{kind:"llm",...t}}VectorSearchEvent(t){return Array.isArray(t.results)&&t.results.every(e=>typeof e=="string")&&(t.results=t.results.map(e=>({pageContent:e,metadata:{}}))),{kind:"vector",...t}}log(t,e){typeof t=="string"?this.collected.push({[t]:e}):this.collected.push(t)}},g=class extends l{constructor(e){super({apiKey:e.apiKey,baseURL:e.baseURL,verbose:e.verbose});a(this,"experiments",new d(this));a(this,"datasets",new u(this));a(this,"tracing",new h(this))}};export{E as DefaultScoreTypes,v as ExperimentStatus,g as Hamming,b as ScoreType};
//# sourceMappingURL=index.js.map