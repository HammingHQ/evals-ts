{"version":3,"sources":["../src/resources/experiments.ts"],"sourcesContent":["import { asyncRunContext } from \"../asyncStorage\";\nimport type { Hamming } from \"../client\";\nimport {\n  CustomScoringConfig,\n  DatasetId,\n  DatasetItem,\n  Experiment,\n  ExperimentItem,\n  ExperimentItemContext,\n  ExperimentStatus,\n  InputType,\n  LocalScorer,\n  MetadataType,\n  OutputType,\n  RunContext,\n  Runner,\n  RunOptions,\n  Score,\n  ScoreType,\n  ScoringFunction,\n  TracingMode,\n} from \"../types\";\nimport { runWorkers } from \"../worker\";\n\nconst MAX_SAMPLES = 10;\n\nfunction newRunContext(itemId: string): RunContext {\n  return {\n    tracing: {\n      experiment: {\n        itemId,\n      },\n    },\n  };\n}\n\nconst defaultScoreTypes = [ScoreType.StringDiff];\n\ninterface RegisteredScoringFunction extends ScoringFunction {\n  registration: CustomScoringConfig;\n}\n\nclass ExperimentItems {\n  private client: Hamming;\n\n  constructor(client: Hamming) {\n    this.client = client;\n  }\n\n  async start(\n    experiment: Experiment,\n    datasetItem: DatasetItem,\n    sampleId?: number,\n  ): Promise<ExperimentItemContext> {\n    const resp = await this.client.fetch(\n      `/experiments/${experiment.id}/items`,\n      {\n        method: \"POST\",\n        body: JSON.stringify({\n          datasetItemId: datasetItem.id,\n          output: {},\n          metrics: {},\n          sampleId,\n        }),\n      },\n    );\n    const data = await resp.json();\n    const item = data.item as ExperimentItem;\n\n    const startTs = Date.now();\n    return {\n      item,\n      startTs,\n    };\n  }\n\n  async end(\n    itemContext: ExperimentItemContext,\n    output: OutputType,\n    scores: Record<string, Score> = {},\n  ) {\n    const { item, startTs } = itemContext;\n    const durationMs = Date.now() - startTs;\n    await this.client.tracing._flush(item.id);\n    // Completing the experiment item should happen after the traces are\n    // flushed, since it will automatically trigger scoring.\n    await this.client.fetch(\n      `/experiments/${item.experimentId}/items/${item.id}`,\n      {\n        method: \"PATCH\",\n        body: JSON.stringify({\n          output,\n          scores,\n          metrics: {\n            durationMs,\n          },\n        }),\n      },\n    );\n  }\n}\n\nexport class Experiments {\n  private client: Hamming;\n  private items: ExperimentItems;\n\n  constructor(client: Hamming) {\n    this.client = client;\n    this.items = new ExperimentItems(this.client);\n  }\n\n  async run(opts: RunOptions, run: Runner) {\n    const { dataset: datasetId } = opts;\n    const dataset = await this.client.datasets.load(datasetId);\n\n    this.client.tracing._setMode(TracingMode.EXPERIMENT);\n\n    const {\n      name = this.generateName(dataset.name),\n      scoring = defaultScoreTypes,\n      metadata = {},\n      sampling,\n    } = opts;\n\n    const sampleCount = sampling ?? 1;\n    if (sampleCount > MAX_SAMPLES) {\n      throw new Error(`The maximum number of samples is ${MAX_SAMPLES}.`);\n    }\n\n    const scoringHelper = new ScoringHelper(this.client, scoring);\n    await scoringHelper.initialize();\n\n    const experiment = await this.start(\n      name,\n      datasetId,\n      scoringHelper.getConfig(),\n      metadata,\n      sampling,\n    );\n    const baseUrl = new URL(this.client.baseURL);\n    const experimentUrl = `${baseUrl.origin}/experiments/${experiment.id}`;\n\n    try {\n      for (let sampleId = 0; sampleId < sampleCount; sampleId++) {\n        if (opts.parallel) {\n          const runFn = async (datasetItem: DatasetItem) => {\n            const itemCtx = await this.items.start(\n              experiment,\n              datasetItem,\n              sampleId,\n            );\n            const output = await asyncRunContext.run(\n              newRunContext(itemCtx.item.id),\n              async () => run(datasetItem.input),\n            );\n            const scores = await scoringHelper.score(\n              datasetItem.input,\n              datasetItem.output,\n              output,\n            );\n            await this.items.end(itemCtx, output, scores);\n          };\n          const workerCount =\n            typeof opts.parallel === \"number\" ? opts.parallel : undefined;\n          await runWorkers(dataset.items, runFn, workerCount);\n        } else {\n          for (const datasetItem of dataset.items) {\n            const itemCtx = await this.items.start(\n              experiment,\n              datasetItem,\n              sampleId,\n            );\n            const output = await asyncRunContext.run(\n              newRunContext(itemCtx.item.id),\n              async () => await run(datasetItem.input),\n            );\n            const scores = await scoringHelper.score(\n              datasetItem.input,\n              datasetItem.output,\n              output,\n            );\n            await this.items.end(itemCtx, output, scores);\n          }\n        }\n      }\n    } catch (err) {\n      await this.end(experiment, ExperimentStatus.FAILED);\n      throw err;\n    } finally {\n      await this.end(experiment);\n      console.log(\"See experiment results at:\", experimentUrl);\n    }\n    return { experimentUrl };\n  }\n\n  private async start(\n    name: string,\n    dataset: DatasetId,\n    scoring: (ScoreType | CustomScoringConfig)[],\n    metadata: MetadataType,\n    sampling?: number,\n  ): Promise<Experiment> {\n    const status = ExperimentStatus.RUNNING;\n    const resp = await this.client.fetch(`/experiments`, {\n      method: \"POST\",\n      body: JSON.stringify({\n        name,\n        dataset,\n        status,\n        scoring,\n        metadata,\n        sampling,\n      }),\n    });\n\n    const data = await resp.json();\n    return data.experiment as Experiment;\n  }\n\n  private async end(\n    experiment: Experiment,\n    status: ExperimentStatus = ExperimentStatus.FINISHED,\n  ) {\n    await this.client.fetch(`/experiments/${experiment.id}`, {\n      method: \"PATCH\",\n      body: JSON.stringify({\n        status,\n      }),\n    });\n  }\n\n  private generateName(datasetName: string): string {\n    const now = new Date();\n    return `Experiment for ${datasetName} - ${now.toLocaleString()}`;\n  }\n}\n\nclass ScoringHelper {\n  private readonly client: Hamming;\n\n  public readonly standardScoring: ScoreType[];\n  public readonly customScoring: ScoringFunction[];\n\n  private registeredFunctions: RegisteredScoringFunction[] = [];\n  private initialized = false;\n\n  constructor(client: Hamming, scoring: (ScoringFunction | ScoreType)[]) {\n    this.client = client;\n\n    this.standardScoring = scoring.filter(\n      (score): score is ScoreType => typeof score === \"string\",\n    );\n    this.customScoring = scoring.filter(\n      (score): score is ScoringFunction => typeof score !== \"string\",\n    );\n  }\n\n  async initialize() {\n    await this.registerScoringFunctions();\n    this.initialized = true;\n  }\n\n  getConfig(): (ScoreType | CustomScoringConfig)[] {\n    if (!this.initialized) {\n      throw new Error(\"ScoringHelper is not initialized\");\n    }\n    return [\n      ...this.standardScoring,\n      ...this.registeredFunctions.map((f) => f.registration),\n    ];\n  }\n\n  async score(\n    input: InputType,\n    expected: OutputType,\n    output: OutputType,\n  ): Promise<Record<string, Score>> {\n    if (!this.initialized) {\n      throw new Error(\"ScoringHelper is not initialized\");\n    }\n    const scores = {} as Record<string, Score>;\n    const promises = this.registeredFunctions\n      .filter((f) => f.scorer.type === \"local\")\n      .map(async (f) => {\n        const scorer = f.scorer as LocalScorer;\n        const score = await scorer.scoreFn({ input, output, expected });\n        scores[f.registration.key_name] = score;\n      });\n    await Promise.allSettled(promises);\n    return scores;\n  }\n\n  private async registerScoringFunctions() {\n    const scoring = this.customScoring.map((scoringFunc) => ({\n      name: scoringFunc.name,\n      version: scoringFunc.version,\n      score_config: scoringFunc.scoreConfig,\n      execution_config: {},\n    }));\n    const resp = await this.client.fetch(`/scoring/register-functions`, {\n      method: \"POST\",\n      body: JSON.stringify({\n        scoring: scoring,\n      }),\n    });\n\n    const data = await resp.json();\n    const registrations = (data.scoring ?? []) as CustomScoringConfig[];\n    this.registeredFunctions = this.customScoring.map(\n      (scoringFunction, idx) => ({\n        ...scoringFunction,\n        registration: registrations[idx],\n      }),\n    );\n  }\n}\n"],"mappings":"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","names":["MAX_SAMPLES","newRunContext","itemId","defaultScoreTypes","ExperimentItems","client","__publicField","experiment","datasetItem","sampleId","item","startTs","itemContext","output","scores","durationMs","Experiments","opts","run","datasetId","dataset","name","scoring","metadata","sampling","sampleCount","scoringHelper","ScoringHelper","experimentUrl","runFn","itemCtx","asyncRunContext","workerCount","runWorkers","err","status","datasetName","score","f","input","expected","promises","scoringFunc","registrations","scoringFunction","idx"]}