{"version":3,"sources":["../src/resources/Tracing.ts"],"names":["Tracing","client","__publicField","mode","experimentItemId","events","rootTrace","traces","event","params","isString","item","hasStringResults","normalizeResult","result","results","trace","keyOrTrace","value","context"],"mappings":"yCAYO,IAAMA,EAAN,KAAc,CAOnB,YAAYC,EAAiB,CAN7BC,EAAA,KAAQ,UACRA,EAAA,KAAQ,YAA0B,CAAC,GACnCA,EAAA,KAAQ,sBAA8B,GAEtCA,EAAA,KAAQ,cAGN,KAAK,OAASD,CAChB,CAEA,SAASE,EAAmB,CAC1B,KAAK,KAAOA,CACd,CAEQ,aAAsB,CAC5B,OAAO,KAAK,qBACd,CAEA,MAAM,OAAOC,EAA0B,CACrC,GAAI,KAAK,oBAAiC,CACxC,QAAQ,KAAK,2CAA2C,EACxD,MACF,CAEA,IAAMC,EAAS,KAAK,UACpB,KAAK,UAAY,CAAC,EAElB,IAAMC,EAAmB,CACvB,GAAI,KAAK,YAAY,EACrB,iBAAAF,EACA,MAAO,CAAE,KAAM,MAAO,CACxB,EAEMG,EAAkB,CAACD,CAAS,EAClC,QAAWE,KAASH,EAClBE,EAAO,KAAK,CACV,GAAI,KAAK,YAAY,EACrB,iBAAAH,EACA,SAAUE,EAAU,GACpB,MAAAE,CACF,CAAC,EAGH,MAAM,KAAK,OAAO,MAAM,UAAW,CACjC,OAAQ,OACR,KAAM,KAAK,UAAU,CACnB,OAAAD,CACF,CAAC,CACH,CAAC,CACH,CAEQ,iBAAiBE,EAAsC,CAC7D,MAAO,CACL,KAAM,MACN,GAAGA,CACL,CACF,CAEQ,gBAAgBA,EAA0C,CAChE,IAAMC,EAAYC,GAAc,OAAOA,GAAS,SAC1CC,EAAmBH,EAAO,SAAS,MAAMC,CAAQ,EACjDG,EAAmBC,GACnB,OAAOA,GAAW,SACb,CAAE,YAAaA,EAAQ,SAAU,CAAC,CAAE,EAEtCA,EAGHC,EAAUH,EACZH,EAAO,SAAS,IAAII,CAAe,EACnCJ,EAAO,QAEX,MAAO,CACL,KAAM,SACN,GAAGA,EACH,QAAAM,CACF,CACF,CAEA,cAAcC,EAAwB,CACpC,GAAI,KAAK,oBAAiC,CACxC,QAAQ,KAAK,2CAA2C,EACxD,MACF,CAEA,KAAK,OAAO,OAAO,IAAI,CACrB,OACA,QAASA,CACX,CAAC,CACH,CAIA,IAAIC,EAAiCC,EAAuB,CAC1D,GAAI,KAAK,oBAAiC,CACxC,IAAMC,EAAU,KAAK,OAAO,WAAW,iBAAiB,EAEpD,OAAOF,GAAe,SACxB,KAAK,cAAc,CACjB,GAAGE,EACH,MAAO,CAAE,CAACF,CAAU,EAAGC,CAAM,CAC/B,CAAC,EAED,KAAK,cAAc,CACjB,GAAGC,EACH,MAAOF,CACT,CAAC,CAEL,MAAW,KAAK,oBACV,OAAOA,GAAe,SACxB,KAAK,UAAU,KAAK,CAAE,CAACA,CAAU,EAAGC,CAAM,CAAC,EAE3C,KAAK,UAAU,KAAKD,CAAU,EAGhC,QAAQ,KAAK,uDAAuD,CACxE,CAEA,cAAcR,EAAgC,CAC5C,KAAK,IAAI,KAAK,iBAAiBA,CAAM,CAAC,CACxC,CAEA,aAAaA,EAAoC,CAC/C,KAAK,IAAI,KAAK,gBAAgBA,CAAM,CAAC,CACvC,CACF","sourcesContent":["import type { Hamming } from \"../index\";\nimport { LogMessageType } from \"../types/asyncLogger\";\nimport { MonitoringTrace } from \"../types/monitoring\";\nimport {\n  Document,\n  GenerationParams,\n  RetrievalEventParams,\n  Trace,\n  TraceEvent,\n  TracingMode,\n} from \"../types/tracing\";\n\nexport class Tracing {\n  private client: Hamming;\n  private collected: TraceEvent[] = [];\n  private currentLocalTraceId: number = 0;\n\n  private mode: TracingMode = TracingMode.OFF;\n\n  constructor(client: Hamming) {\n    this.client = client;\n  }\n\n  _setMode(mode: TracingMode) {\n    this.mode = mode;\n  }\n\n  private nextTraceId(): number {\n    return this.currentLocalTraceId++;\n  }\n\n  async _flush(experimentItemId: string) {\n    if (this.mode !== TracingMode.EXPERIMENT) {\n      console.warn(`Tracing mode must be set to <experiment>!`);\n      return;\n    }\n\n    const events = this.collected;\n    this.collected = [];\n\n    const rootTrace: Trace = {\n      id: this.nextTraceId(),\n      experimentItemId,\n      event: { kind: \"root\" },\n    };\n\n    const traces: Trace[] = [rootTrace];\n    for (const event of events) {\n      traces.push({\n        id: this.nextTraceId(),\n        experimentItemId,\n        parentId: rootTrace.id,\n        event,\n      });\n    }\n\n    await this.client.fetch(`/traces`, {\n      method: \"POST\",\n      body: JSON.stringify({\n        traces,\n      }),\n    });\n  }\n\n  private _generationEvent(params: GenerationParams): TraceEvent {\n    return {\n      kind: \"llm\",\n      ...params,\n    };\n  }\n\n  private _retrievalEvent(params: RetrievalEventParams): TraceEvent {\n    const isString = (item: any) => typeof item === \"string\";\n    const hasStringResults = params.results?.every(isString);\n    const normalizeResult = (result: string | Document): Document => {\n      if (typeof result === \"string\") {\n        return { pageContent: result, metadata: {} };\n      }\n      return result;\n    };\n\n    const results = hasStringResults\n      ? params.results?.map(normalizeResult)\n      : params.results;\n\n    return {\n      kind: \"vector\",\n      ...params,\n      results,\n    };\n  }\n\n  _logLiveTrace(trace: MonitoringTrace) {\n    if (this.mode !== TracingMode.MONITORING) {\n      console.warn(`Tracing mode must be set to <monitoring>!`);\n      return;\n    }\n\n    this.client.logger.log({\n      type: LogMessageType.MONITORING,\n      payload: trace,\n    });\n  }\n\n  log(key: string, value: unknown): void;\n  log(trace: TraceEvent): void;\n  log(keyOrTrace: string | TraceEvent, value?: unknown): void {\n    if (this.mode === TracingMode.MONITORING) {\n      const context = this.client.monitoring._getTraceContext();\n\n      if (typeof keyOrTrace === \"string\") {\n        this._logLiveTrace({\n          ...context,\n          event: { [keyOrTrace]: value },\n        });\n      } else {\n        this._logLiveTrace({\n          ...context,\n          event: keyOrTrace,\n        });\n      }\n    } else if (this.mode === TracingMode.EXPERIMENT) {\n      if (typeof keyOrTrace === \"string\") {\n        this.collected.push({ [keyOrTrace]: value });\n      } else {\n        this.collected.push(keyOrTrace);\n      }\n    } else\n      console.warn(\"Attempt to send a log trace, but tracing mode is off!\");\n  }\n\n  logGeneration(params: GenerationParams): void {\n    this.log(this._generationEvent(params));\n  }\n\n  logRetrieval(params: RetrievalEventParams): void {\n    this.log(this._retrievalEvent(params));\n  }\n}\n"]}