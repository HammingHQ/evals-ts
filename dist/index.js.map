{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { HttpClient } from \"./httpClient\";\nimport { runWorkers } from \"./worker\";\n\nexport enum ExperimentStatus {\n  CREATED = \"CREATED\",\n  RUNNING = \"RUNNING\",\n  SCORING = \"SCORING\",\n  SCORING_FAILED = \"SCORING_FAILED\",\n  FINISHED = \"FINISHED\",\n  FAILED = \"FAILED\",\n}\n\nexport interface Experiment {\n  id: string;\n  name: string;\n  description?: string | null;\n  datasetId: number;\n  datasetVersionId?: number;\n  status: ExperimentStatus;\n}\n\nexport interface ExperimentItemMetrics {\n  durationMs?: number;\n}\n\nexport interface ExperimentItem {\n  id: string;\n  experimentId: string;\n  datasetItemId: string;\n  output: OutputType;\n  metrics: ExperimentItemMetrics;\n}\n\nexport interface ExperimentItemContext {\n  item: ExperimentItem;\n  startTs: number;\n}\n\nexport type InputType = Record<string, any>;\nexport type OutputType = Record<string, any>;\nexport type MetadataType = Record<string, any>;\n\nexport interface DatasetItemValue {\n  input: InputType;\n  output: OutputType;\n  metadata: MetadataType;\n}\n\ntype DatasetItem = DatasetItemValue & { id: string };\n\ninterface Dataset {\n  id: string;\n  name: string;\n  description?: string;\n}\n\ntype DatasetWithItems = Dataset & { items: DatasetItem[] };\n\nclass ExperimentItems {\n  private client: Hamming;\n\n  constructor(client: Hamming) {\n    this.client = client;\n  }\n\n  async start(\n    experiment: Experiment,\n    datasetItem: DatasetItem,\n  ): Promise<ExperimentItemContext> {\n    const resp = await this.client.fetch(\n      `/experiments/${experiment.id}/items`,\n      {\n        method: \"POST\",\n        body: JSON.stringify({\n          datasetItemId: datasetItem.id,\n          output: {},\n          metrics: {},\n        }),\n      },\n    );\n    const data = await resp.json();\n    const item = data.item as ExperimentItem;\n\n    const startTs = Date.now();\n    return {\n      item,\n      startTs,\n    };\n  }\n\n  async end(itemContext: ExperimentItemContext, output: OutputType) {\n    const { item, startTs } = itemContext;\n    const durationMs = Date.now() - startTs;\n    await this.client.tracing._flush(item.id);\n    // Completing the experiment item should happen after the traces are\n    // flushed, since it will automatically trigger scoring.\n    await this.client.fetch(\n      `/experiments/${item.experimentId}/items/${item.id}`,\n      {\n        method: \"PATCH\",\n        body: JSON.stringify({\n          output,\n          metrics: {\n            durationMs,\n          },\n        }),\n      },\n    );\n  }\n}\n\nclass Experiments {\n  private client: Hamming;\n  private items: ExperimentItems;\n\n  constructor(client: Hamming) {\n    this.client = client;\n    this.items = new ExperimentItems(this.client);\n  }\n\n  async run(opts: RunOptions, run: Runner) {\n    const { dataset: datasetId } = opts;\n    const dataset = await this.client.datasets.load(datasetId);\n\n    const {\n      name = this.generateName(dataset.name),\n      scoring = DefaultScoreTypes,\n      metadata = {},\n    } = opts;\n\n    const experiment = await this.start(name, datasetId, scoring, metadata);\n    const baseUrl = new URL(this.client.baseURL);\n    const experimentUrl = `${baseUrl.origin}/experiments/${experiment.id}`;\n\n    try {\n      if (opts.parallel) {\n        const runFn = async (item: DatasetItem) => {\n          const itemCtx = await this.items.start(experiment, item);\n          const runCtx: RunContext = {\n            tracing: new TracingWrapper(this.client.tracing, itemCtx.item.id),\n          };\n          const output = await run(item.input, runCtx);\n          await this.items.end(itemCtx, output);\n        };\n        const workerCount =\n          typeof opts.parallel === \"number\" ? opts.parallel : undefined;\n        await runWorkers(dataset.items, runFn, workerCount);\n      } else {\n        for (const datasetItem of dataset.items) {\n          const itemCtx = await this.items.start(experiment, datasetItem);\n          const runCtx: RunContext = {\n            tracing: new TracingWrapper(this.client.tracing, itemCtx.item.id),\n          };\n          const output = await run(datasetItem.input, runCtx);\n          await this.items.end(itemCtx, output);\n        }\n      }\n    } catch (err) {\n      await this.end(experiment, ExperimentStatus.FAILED);\n      throw err;\n    } finally {\n      await this.end(experiment);\n      console.log(\"See experiment results at:\", experimentUrl);\n    }\n    return { experimentUrl };\n  }\n\n  private async start(\n    name: string,\n    dataset: DatasetId,\n    scoring: ScoreType[],\n    metadata: MetadataType,\n  ): Promise<Experiment> {\n    const status = ExperimentStatus.RUNNING;\n    const resp = await this.client.fetch(`/experiments`, {\n      method: \"POST\",\n      body: JSON.stringify({\n        name,\n        dataset,\n        status,\n        scoring,\n        metadata,\n      }),\n    });\n\n    const data = await resp.json();\n    return data.experiment as Experiment;\n  }\n\n  private async end(\n    experiment: Experiment,\n    status: ExperimentStatus = ExperimentStatus.FINISHED,\n  ) {\n    await this.client.fetch(`/experiments/${experiment.id}`, {\n      method: \"PATCH\",\n      body: JSON.stringify({\n        status,\n      }),\n    });\n  }\n\n  private generateName(datasetName: string): string {\n    const now = new Date();\n    return `Experiment for ${datasetName} - ${now.toLocaleString()}`;\n  }\n}\n\nexport type DatasetId = string;\n\ninterface RunOptions {\n  dataset: DatasetId;\n  name?: string;\n  scoring?: ScoreType[];\n  metadata?: MetadataType;\n  parallel?: boolean | number;\n}\n\nexport type RunContext = {\n  tracing: ITracing;\n};\n\nexport type Runner = (input: InputType, ctx: RunContext) => Promise<OutputType>;\n\nexport enum ScoreType {\n  AccuracyAI = \"accuracy_ai\",\n  FactsCompare = \"facts_compare\",\n  ContextRecall = \"context_recall\",\n  ContextPrecision = \"context_precision\",\n  Hallucination = \"hallucination\",\n  StringDiff = \"string_diff\",\n  Refusal = \"refusal\",\n  SqlAst = \"sql_ast\",\n}\n\nexport const DefaultScoreTypes = [ScoreType.StringDiff];\n\nclass Datasets {\n  private client: Hamming;\n\n  constructor(client: Hamming) {\n    this.client = client;\n  }\n\n  async load(id: DatasetId): Promise<DatasetWithItems> {\n    const resp = await this.client.fetch(`/datasets/${id}`, {\n      method: \"GET\",\n    });\n\n    let data: { dataset: DatasetWithItems };\n    try {\n      data = await resp.json();\n    } catch (error) {\n      throw new Error(\n        `Failed to parse dataset response as JSON for dataset ID: ${id}: ${error}`,\n      );\n    }\n    return data.dataset as DatasetWithItems;\n  }\n\n  async list(): Promise<Dataset[]> {\n    const resp = await this.client.fetch(`/datasets`);\n    const data = await resp.json();\n    return data.datasets as Dataset[];\n  }\n\n  async create(opts: CreateDatasetOptions): Promise<DatasetWithItems> {\n    const { name, description, items } = opts;\n    const resp = await this.client.fetch(\"/datasets\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        name,\n        description,\n        items,\n      }),\n    });\n    const data = await resp.json();\n    return data.dataset as DatasetWithItems;\n  }\n}\n\nexport interface CreateDatasetOptions {\n  name: string;\n  description?: string;\n  items: DatasetItemValue[];\n}\n\ntype TraceEvent = Record<string, unknown>;\n\ninterface GenerationParams {\n  input?: string;\n  output?: string;\n  metadata?: {\n    model?: string;\n  };\n}\n\ninterface Document {\n  pageContent: string;\n  metadata: Record<string, any>;\n}\n\ninterface RetrievalParams {\n  query?: string;\n  results?: Document[] | string[];\n  metadata?: {\n    engine?: string;\n  };\n}\n\ninterface Trace {\n  id: number;\n  experimentItemId: string;\n  parentId?: number;\n  event: TraceEvent;\n}\n\ninterface ITracing {\n  logGeneration(params: GenerationParams): void;\n  logRetrieval(params: RetrievalParams): void;\n  log(key: string, value: unknown): void;\n  log(trace: TraceEvent): void;\n}\n\nclass Tracing implements ITracing {\n  private client: Hamming;\n  private collected: Record<string, TraceEvent[]> = {};\n  private currentLocalTraceId: number = 0;\n\n  constructor(client: Hamming) {\n    this.client = client;\n  }\n\n  private nextTraceId(): number {\n    return this.currentLocalTraceId++;\n  }\n\n  async _flush(experimentItemId: string) {\n    const events = this.collected[experimentItemId] ?? [];\n    delete this.collected[experimentItemId];\n\n    const rootTrace: Trace = {\n      id: this.nextTraceId(),\n      experimentItemId,\n      event: { kind: \"root\" },\n    };\n\n    const traces: Trace[] = [rootTrace];\n\n    for (const event of events) {\n      traces.push({\n        id: this.nextTraceId(),\n        experimentItemId,\n        parentId: rootTrace.id,\n        event,\n      });\n    }\n\n    await this.client.fetch(`/traces`, {\n      method: \"POST\",\n      body: JSON.stringify({\n        traces,\n      }),\n    });\n  }\n\n  private _generationEvent(params: GenerationParams): TraceEvent {\n    return {\n      kind: \"llm\",\n      ...params,\n    };\n  }\n\n  private _retrievalEvent(params: RetrievalParams): TraceEvent {\n    const isString = (item: any) => typeof item === \"string\";\n    const hasStringResults = params.results?.every(isString);\n    const normalizeResult = (result: string | Document): Document => {\n      if (typeof result === \"string\") {\n        return { pageContent: result, metadata: {} };\n      }\n      return result;\n    };\n\n    const results = hasStringResults\n      ? params.results?.map(normalizeResult)\n      : params.results;\n\n    return {\n      kind: \"vector\",\n      ...params,\n      results,\n    };\n  }\n\n  log(key: string, value: unknown, ctx?: TracingContext): void;\n  log(trace: TraceEvent, ctx?: TracingContext): void;\n  log(\n    keyOrTrace: string | TraceEvent,\n    valueOrCtx?: unknown | TracingContext,\n    ctx?: TracingContext,\n  ): void {\n    const { event, tracingCtx } = (() => {\n      const isKeyValue = typeof keyOrTrace === \"string\";\n      if (isKeyValue) {\n        const key = keyOrTrace as string;\n        const value = valueOrCtx as unknown;\n        const event: TraceEvent = { [key]: value };\n        const tracingCtx = ctx;\n        return { event, tracingCtx };\n      } else {\n        const event = keyOrTrace as TraceEvent;\n        const tracingCtx = valueOrCtx as TracingContext;\n        return { event, tracingCtx };\n      }\n    })();\n\n    const experimentItemId = tracingCtx?.experiment?.itemId;\n    if (!experimentItemId) {\n      throw new Error(\n        \"Experiment item ID not found, use the new API 'ctx.tracing'.\",\n      );\n    }\n    if (!this.collected[experimentItemId]) {\n      this.collected[experimentItemId] = [];\n    }\n    this.collected[experimentItemId].push(event);\n  }\n\n  logGeneration(params: GenerationParams, ctx?: TracingContext): void {\n    this.log(this._generationEvent(params), ctx);\n  }\n\n  logRetrieval(params: RetrievalParams, ctx?: TracingContext): void {\n    this.log(this._retrievalEvent(params), ctx);\n  }\n}\n\ninterface TracingContext {\n  experiment?: {\n    itemId?: string;\n  };\n}\n\nclass TracingWrapper implements ITracing {\n  private wrapped: Tracing;\n  private ctx: TracingContext;\n\n  constructor(tracing: Tracing, experimentItemId: string) {\n    this.wrapped = tracing;\n    this.ctx = {\n      experiment: { itemId: experimentItemId },\n    };\n  }\n\n  logGeneration(params: GenerationParams): void {\n    this.wrapped.logGeneration(params, this.ctx);\n  }\n\n  logRetrieval(params: RetrievalParams): void {\n    this.wrapped.logRetrieval(params, this.ctx);\n  }\n\n  log(keyOrTrace: string | TraceEvent, value?: unknown): void {\n    if (typeof keyOrTrace === \"string\") {\n      this.wrapped.log(keyOrTrace, value, this.ctx);\n    } else {\n      this.wrapped.log(keyOrTrace, this.ctx);\n    }\n  }\n}\n\nexport interface ClientOptions {\n  apiKey: string;\n  baseURL?: string;\n}\nconst CLIENT_OPTIONS_KEYS: (keyof ClientOptions)[] = [\"apiKey\", \"baseURL\"];\n\nexport class Hamming extends HttpClient {\n  constructor(config: ClientOptions) {\n    const unexpectedConfigKeys = Object.keys(config).filter(\n      (key) => !CLIENT_OPTIONS_KEYS.includes(key as keyof ClientOptions),\n    );\n\n    if (unexpectedConfigKeys.length > 0) {\n      console.warn(\n        `WARNING: Unexpected config keys found: ${unexpectedConfigKeys.join(\n          \", \",\n        )}. Valid config keys are: ${CLIENT_OPTIONS_KEYS.join(\n          \", \",\n        )}. The unexpected keys will be ignored.`,\n      );\n    }\n\n    super({\n      apiKey: config.apiKey,\n      baseURL: config.baseURL ?? \"https://app.hamming.ai/api/rest\",\n    });\n  }\n\n  experiments = new Experiments(this);\n  datasets = new Datasets(this);\n  tracing = new Tracing(this);\n}\n"],"mappings":"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","names":["ExperimentStatus","ExperimentItems","client","__publicField","experiment","datasetItem","item","startTs","itemContext","output","durationMs","Experiments","opts","run","datasetId","dataset","name","scoring","DefaultScoreTypes","metadata","experimentUrl","runFn","itemCtx","runCtx","TracingWrapper","workerCount","runWorkers","err","status","datasetName","ScoreType","Datasets","id","resp","data","error","description","items","Tracing","experimentItemId","events","rootTrace","traces","event","params","isString","hasStringResults","normalizeResult","result","results","keyOrTrace","valueOrCtx","ctx","tracingCtx","key","value","tracing","CLIENT_OPTIONS_KEYS","Hamming","HttpClient","config","unexpectedConfigKeys"]}