{"version":3,"sources":["../src/resources/tracing.ts"],"names":["TracerBase","params","isString","item","hasStringResults","normalizeResult","result","results","keyOrTrace","value","event","updatedParams","Tracing","client","__publicField","mode","experimentItemId","events","rootTrace","traces","trace","runCtx","asyncRunContext","itemId"],"mappings":"6EAcO,IAAeA,EAAf,KAA8C,CAG3C,iBAAiBC,EAAsC,CAC7D,MAAO,CACL,KAAM,MACN,GAAGA,CACL,CACF,CAEQ,gBAAgBA,EAAqC,CAC3D,IAAMC,EAAYC,GAAc,OAAOA,GAAS,SAC1CC,EAAmBH,EAAO,SAAS,MAAMC,CAAQ,EACjDG,EAAmBC,GACnB,OAAOA,GAAW,SACb,CAAE,YAAaA,EAAQ,SAAU,CAAC,CAAE,EAEtCA,EAGHC,EAAUH,EACZH,EAAO,SAAS,IAAII,CAAe,EACnCJ,EAAO,QAEX,MAAO,CACL,KAAM,SACN,GAAGA,EACH,QAAAM,CACF,CACF,CAIA,IAAIC,EAAiCC,EAAuB,CAC1D,IAAMC,EACe,OAAOF,GAAe,SAGb,CAAE,CADhBA,CACoB,EAAGC,CAAM,EAG3BD,EAIlB,KAAK,SAASE,CAAK,CACrB,CAEA,cAAcT,EAAgC,CAC5C,IAAMU,EAAkC,CACtC,GAAGV,EACH,SAAU,CACR,GAAGA,EAAO,SAEV,MAAOA,EAAO,UAAU,OAAS,CAAC,CAACA,EAAO,UAAU,aACtD,CACF,EACA,KAAK,IAAI,KAAK,iBAAiBU,CAAa,CAAC,CAC/C,CAEA,aAAaV,EAA+B,CAC1C,KAAK,IAAI,KAAK,gBAAgBA,CAAM,CAAC,CACvC,CACF,EAEaW,EAAN,cAAsBZ,CAA+B,CAO1D,YAAYa,EAAiB,CAC3B,MAAM,EAPRC,EAAA,KAAQ,UACRA,EAAA,KAAQ,YAA0C,CAAC,GACnDA,EAAA,KAAQ,sBAA8B,GAEtCA,EAAA,KAAQ,cAIN,KAAK,OAASD,CAChB,CAEA,SAASE,EAAmB,CAC1B,KAAK,KAAOA,CACd,CAEQ,aAAsB,CAC5B,OAAO,KAAK,qBACd,CAEA,MAAM,OAAOC,EAA0B,CACrC,GAAI,KAAK,oBAAiC,CACxC,QAAQ,KAAK,2CAA2C,EACxD,MACF,CAEA,IAAMC,EAAS,KAAK,UAAUD,CAAgB,GAAK,CAAC,EACpD,OAAO,KAAK,UAAUA,CAAgB,EAEtC,IAAME,EAAmB,CACvB,GAAI,KAAK,YAAY,EACrB,iBAAAF,EACA,MAAO,CAAE,KAAM,MAAO,CACxB,EAEMG,EAAkB,CAACD,CAAS,EAElC,QAAWR,KAASO,EAClBE,EAAO,KAAK,CACV,GAAI,KAAK,YAAY,EACrB,iBAAAH,EACA,SAAUE,EAAU,GACpB,MAAAR,CACF,CAAC,EAGH,MAAM,KAAK,OAAO,MAAM,UAAW,CACjC,OAAQ,OACR,KAAM,KAAK,UAAU,CACnB,OAAAS,CACF,CAAC,CACH,CAAC,CACH,CAEA,cAAcC,EAAwB,CACpC,GAAI,KAAK,oBAAiC,CACxC,QAAQ,KAAK,2CAA2C,EACxD,MACF,CAEA,KAAK,OAAO,QAAQ,IAAI,CACtB,OACA,QAASA,CACX,CAAC,CACH,CAEA,SAASV,EAAmB,CAC1B,IAAMW,EAASC,EAAgB,SAAS,EACxC,GAAI,KAAK,oBAAiC,CACxC,IAAMC,EAASF,GAAQ,SAAS,YAAY,OAC5C,GAAI,CAACE,EAAQ,CACX,QAAQ,MAAM,uDAAuD,EACrE,MACF,CACK,KAAK,UAAUA,CAAM,IACxB,KAAK,UAAUA,CAAM,EAAI,CAAC,GAE5B,KAAK,UAAUA,CAAM,EAAE,KAAKb,CAAK,CACnC,SAAW,KAAK,oBAAiC,CAC/C,IAAMU,EAAQ,KAAK,OAAO,WAAW,iBAAiBC,CAAM,EAC5D,GAAI,CAACD,EACH,OAEF,KAAK,cAAc,CACjB,MAAAV,EACA,GAAGU,CACL,CAAC,CACH,MACE,QAAQ,KAAK,uDAAuD,CAExE,CACF","sourcesContent":["import { asyncRunContext } from \"../asyncStorage\";\nimport type { Hamming } from \"../client\";\nimport {\n  Document,\n  GenerationParams,\n  ITracing,\n  LogMessageType,\n  MonitoringTrace,\n  RetrievalParams,\n  Trace,\n  TraceEvent,\n  TracingMode,\n} from \"../types\";\n\nexport abstract class TracerBase implements ITracing {\n  abstract logEvent(event: TraceEvent): void;\n\n  private _generationEvent(params: GenerationParams): TraceEvent {\n    return {\n      kind: \"llm\",\n      ...params,\n    };\n  }\n\n  private _retrievalEvent(params: RetrievalParams): TraceEvent {\n    const isString = (item: any) => typeof item === \"string\";\n    const hasStringResults = params.results?.every(isString);\n    const normalizeResult = (result: string | Document): Document => {\n      if (typeof result === \"string\") {\n        return { pageContent: result, metadata: {} };\n      }\n      return result;\n    };\n\n    const results = hasStringResults\n      ? params.results?.map(normalizeResult)\n      : params.results;\n\n    return {\n      kind: \"vector\",\n      ...params,\n      results,\n    };\n  }\n\n  log(key: string, value: unknown): void;\n  log(trace: TraceEvent): void;\n  log(keyOrTrace: string | TraceEvent, value?: unknown): void {\n    const event = (() => {\n      const isKeyValue = typeof keyOrTrace === \"string\";\n      if (isKeyValue) {\n        const key = keyOrTrace as string;\n        const event: TraceEvent = { [key]: value };\n        return event;\n      } else {\n        const event = keyOrTrace as TraceEvent;\n        return event;\n      }\n    })();\n    this.logEvent(event);\n  }\n\n  logGeneration(params: GenerationParams): void {\n    const updatedParams: GenerationParams = {\n      ...params,\n      metadata: {\n        ...params.metadata,\n        // Error is true if either error or error_message is set, false otherwise\n        error: params.metadata?.error || !!params.metadata?.error_message,\n      },\n    };\n    this.log(this._generationEvent(updatedParams));\n  }\n\n  logRetrieval(params: RetrievalParams): void {\n    this.log(this._retrievalEvent(params));\n  }\n}\n\nexport class Tracing extends TracerBase implements ITracing {\n  private client: Hamming;\n  private collected: Record<string, TraceEvent[]> = {};\n  private currentLocalTraceId: number = 0;\n\n  private mode: TracingMode = TracingMode.OFF;\n\n  constructor(client: Hamming) {\n    super();\n    this.client = client;\n  }\n\n  _setMode(mode: TracingMode) {\n    this.mode = mode;\n  }\n\n  private nextTraceId(): number {\n    return this.currentLocalTraceId++;\n  }\n\n  async _flush(experimentItemId: string) {\n    if (this.mode !== TracingMode.EXPERIMENT) {\n      console.warn(`Tracing mode must be set to <experiment>!`);\n      return;\n    }\n\n    const events = this.collected[experimentItemId] ?? [];\n    delete this.collected[experimentItemId];\n\n    const rootTrace: Trace = {\n      id: this.nextTraceId(),\n      experimentItemId,\n      event: { kind: \"root\" },\n    };\n\n    const traces: Trace[] = [rootTrace];\n\n    for (const event of events) {\n      traces.push({\n        id: this.nextTraceId(),\n        experimentItemId,\n        parentId: rootTrace.id,\n        event,\n      });\n    }\n\n    await this.client.fetch(`/traces`, {\n      method: \"POST\",\n      body: JSON.stringify({\n        traces,\n      }),\n    });\n  }\n\n  _logLiveTrace(trace: MonitoringTrace) {\n    if (this.mode !== TracingMode.MONITORING) {\n      console.warn(`Tracing mode must be set to <monitoring>!`);\n      return;\n    }\n\n    this.client._logger.log({\n      type: LogMessageType.MONITORING,\n      payload: trace,\n    });\n  }\n\n  logEvent(event: TraceEvent) {\n    const runCtx = asyncRunContext.getStore();\n    if (this.mode === TracingMode.EXPERIMENT) {\n      const itemId = runCtx?.tracing?.experiment?.itemId;\n      if (!itemId) {\n        console.error(\"Unable to log trace event without experiment item ID.\");\n        return;\n      }\n      if (!this.collected[itemId]) {\n        this.collected[itemId] = [];\n      }\n      this.collected[itemId].push(event);\n    } else if (this.mode === TracingMode.MONITORING) {\n      const trace = this.client.monitoring._getTraceContext(runCtx);\n      if (!trace) {\n        return;\n      }\n      this._logLiveTrace({\n        event,\n        ...trace,\n      });\n    } else {\n      console.warn(\"Attempt to send a log trace, but tracing mode is off!\");\n    }\n  }\n}\n"]}