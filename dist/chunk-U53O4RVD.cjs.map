{"version":3,"sources":["../src/resources/experiments.ts"],"names":["newRunContext","itemId","defaultScoreTypes","ExperimentItems","client","__publicField","experiment","datasetItem","item","startTs","itemContext","output","durationMs","Experiments","opts","run","datasetId","dataset","name","scoring","metadata","experimentUrl","runFn","itemCtx","asyncRunContext","workerCount","runWorkers","err","status","datasetName"],"mappings":"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","sourcesContent":["import { asyncRunContext } from \"../asyncStorage\";\nimport type { Hamming } from \"../client\";\nimport {\n  DatasetId,\n  DatasetItem,\n  Experiment,\n  ExperimentItem,\n  ExperimentItemContext,\n  ExperimentStatus,\n  MetadataType,\n  OutputType,\n  RunContext,\n  RunOptions,\n  Runner,\n  ScoreType,\n} from \"../types\";\nimport { runWorkers } from \"../worker\";\n\nfunction newRunContext(itemId: string): RunContext {\n  return {\n    tracing: {\n      experiment: {\n        itemId,\n      },\n    },\n  };\n}\n\nconst defaultScoreTypes = [ScoreType.StringDiff];\n\nclass ExperimentItems {\n  private client: Hamming;\n\n  constructor(client: Hamming) {\n    this.client = client;\n  }\n\n  async start(\n    experiment: Experiment,\n    datasetItem: DatasetItem,\n  ): Promise<ExperimentItemContext> {\n    const resp = await this.client.fetch(\n      `/experiments/${experiment.id}/items`,\n      {\n        method: \"POST\",\n        body: JSON.stringify({\n          datasetItemId: datasetItem.id,\n          output: {},\n          metrics: {},\n        }),\n      },\n    );\n    const data = await resp.json();\n    const item = data.item as ExperimentItem;\n\n    const startTs = Date.now();\n    return {\n      item,\n      startTs,\n    };\n  }\n\n  async end(itemContext: ExperimentItemContext, output: OutputType) {\n    const { item, startTs } = itemContext;\n    const durationMs = Date.now() - startTs;\n    await this.client.tracing._flush(item.id);\n    // Completing the experiment item should happen after the traces are\n    // flushed, since it will automatically trigger scoring.\n    await this.client.fetch(\n      `/experiments/${item.experimentId}/items/${item.id}`,\n      {\n        method: \"PATCH\",\n        body: JSON.stringify({\n          output,\n          metrics: {\n            durationMs,\n          },\n        }),\n      },\n    );\n  }\n}\n\nexport class Experiments {\n  private client: Hamming;\n  private items: ExperimentItems;\n\n  constructor(client: Hamming) {\n    this.client = client;\n    this.items = new ExperimentItems(this.client);\n  }\n\n  async run(opts: RunOptions, run: Runner) {\n    const { dataset: datasetId } = opts;\n    const dataset = await this.client.datasets.load(datasetId);\n\n    const {\n      name = this.generateName(dataset.name),\n      scoring = defaultScoreTypes,\n      metadata = {},\n    } = opts;\n\n    const experiment = await this.start(name, datasetId, scoring, metadata);\n    const baseUrl = new URL(this.client.baseURL);\n    const experimentUrl = `${baseUrl.origin}/experiments/${experiment.id}`;\n\n    try {\n      if (opts.parallel) {\n        const runFn = async (item: DatasetItem) => {\n          const itemCtx = await this.items.start(experiment, item);\n          const output = await asyncRunContext.run(\n            newRunContext(itemCtx.item.id),\n            async () => run(item.input),\n          );\n          await this.items.end(itemCtx, output);\n        };\n        const workerCount =\n          typeof opts.parallel === \"number\" ? opts.parallel : undefined;\n        await runWorkers(dataset.items, runFn, workerCount);\n      } else {\n        for (const datasetItem of dataset.items) {\n          const itemCtx = await this.items.start(experiment, datasetItem);\n          const output = await asyncRunContext.run(\n            newRunContext(itemCtx.item.id),\n            async () => await run(datasetItem.input),\n          );\n          await this.items.end(itemCtx, output);\n        }\n      }\n    } catch (err) {\n      await this.end(experiment, ExperimentStatus.FAILED);\n      throw err;\n    } finally {\n      await this.end(experiment);\n      console.log(\"See experiment results at:\", experimentUrl);\n    }\n    return { experimentUrl };\n  }\n\n  private async start(\n    name: string,\n    dataset: DatasetId,\n    scoring: ScoreType[],\n    metadata: MetadataType,\n  ): Promise<Experiment> {\n    const status = ExperimentStatus.RUNNING;\n    const resp = await this.client.fetch(`/experiments`, {\n      method: \"POST\",\n      body: JSON.stringify({\n        name,\n        dataset,\n        status,\n        scoring,\n        metadata,\n      }),\n    });\n\n    const data = await resp.json();\n    return data.experiment as Experiment;\n  }\n\n  private async end(\n    experiment: Experiment,\n    status: ExperimentStatus = ExperimentStatus.FINISHED,\n  ) {\n    await this.client.fetch(`/experiments/${experiment.id}`, {\n      method: \"PATCH\",\n      body: JSON.stringify({\n        status,\n      }),\n    });\n  }\n\n  private generateName(datasetName: string): string {\n    const now = new Date();\n    return `Experiment for ${datasetName} - ${now.toLocaleString()}`;\n  }\n}\n"]}