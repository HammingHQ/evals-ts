{"version":3,"sources":["../src/index.ts","../src/fetchClient.ts","../src/httpClient.ts","../src/utils/manualResetEvent.ts","../src/logger.ts","../src/prompt-template.ts","../src/resources/anthropic.ts","../src/resources/anthropic-client.ts","../src/resources/anthropic-bedrock-client.ts","../src/resources/datasets.ts","../src/asyncStorage.ts","../src/types.ts","../src/worker.ts","../src/resources/experiments.ts","../src/resources/tracing.ts","../src/resources/monitoring.ts","../src/resources/openai-client.ts","../src/resources/prompts.ts","../src/client.ts"],"sourcesContent":["export * from \"./client\";\nexport * from \"./types\";\nexport * from \"./prompt-template\";\n","type RequestDelayFunction = (\n  attempt: number,\n  error: Error | null,\n  response: Response | null,\n  input?: string | Request,\n) => number;\n\ntype RequestRetryOnFunction = (\n  attempt: number,\n  error: Error | null,\n  response: Response | null,\n) => boolean | Promise<boolean>;\n\nexport interface RequestInitRetryParams {\n  retries?: number;\n  retryDelay?: number | RequestDelayFunction;\n  retryOn?: number[] | RequestRetryOnFunction;\n}\n\nexport type RequestInitWithRetry = RequestInit & RequestInitRetryParams;\n\nclass FetchClient {\n  private retries: number;\n  private retryDelay: number | RequestDelayFunction;\n  private retryOn: number[] | RequestRetryOnFunction;\n\n  constructor(defaults?: RequestInitRetryParams) {\n    const baseDefaults: RequestInitRetryParams = {\n      retries: 3,\n      retryDelay: 1000,\n      retryOn: [],\n    };\n\n    const finalDefaults = { ...baseDefaults, ...defaults };\n\n    this.validateDefaults(finalDefaults);\n\n    this.retries = finalDefaults.retries!;\n    this.retryDelay = finalDefaults.retryDelay!;\n    this.retryOn = finalDefaults.retryOn!;\n  }\n\n  private validateDefaults(defaults: RequestInitRetryParams): void {\n    if (\n      defaults.retries !== undefined &&\n      !this.isPositiveInteger(defaults.retries)\n    ) {\n      throw new ArgumentError(\"retries must be a positive integer\");\n    }\n\n    if (\n      defaults.retryDelay !== undefined &&\n      !this.isPositiveInteger(defaults.retryDelay) &&\n      typeof defaults.retryDelay !== \"function\"\n    ) {\n      throw new ArgumentError(\n        \"retryDelay must be a positive integer or a function returning a positive integer\",\n      );\n    }\n\n    if (\n      defaults.retryOn !== undefined &&\n      !Array.isArray(defaults.retryOn) &&\n      typeof defaults.retryOn !== \"function\"\n    ) {\n      throw new ArgumentError(\"retryOn property expects an array or function\");\n    }\n  }\n\n  private isPositiveInteger(value: any): value is number {\n    return Number.isInteger(value) && value >= 0;\n  }\n\n  public fetchRetry(\n    input: RequestInfo,\n    init?: RequestInitWithRetry,\n  ): Promise<Response> {\n    let retries = this.retries;\n    let retryDelay = this.retryDelay;\n    let retryOn = this.retryOn;\n\n    if (init) {\n      if (init.retries !== undefined && this.isPositiveInteger(init.retries)) {\n        retries = init.retries;\n      }\n\n      if (init.retryDelay !== undefined) {\n        if (\n          this.isPositiveInteger(init.retryDelay) ||\n          typeof init.retryDelay === \"function\"\n        ) {\n          retryDelay = init.retryDelay;\n        }\n      }\n\n      if (init.retryOn) {\n        if (Array.isArray(init.retryOn) || typeof init.retryOn === \"function\") {\n          retryOn = init.retryOn;\n        }\n      }\n    }\n\n    return new Promise((resolve, reject) => {\n      const wrappedFetch = (attempt: number) => {\n        const _input = input instanceof Request ? input.clone() : input;\n        fetch(_input, init)\n          .then((response) => {\n            if (Array.isArray(retryOn) && !retryOn.includes(response.status)) {\n              resolve(response);\n            } else if (typeof retryOn === \"function\") {\n              Promise.resolve(retryOn(attempt, null, response))\n                .then((retryOnResponse) => {\n                  if (retryOnResponse) {\n                    retry(attempt, null, response);\n                  } else {\n                    resolve(response);\n                  }\n                })\n                .catch(reject);\n            } else {\n              if (attempt < retries) {\n                retry(attempt, null, response);\n              } else {\n                resolve(response);\n              }\n            }\n          })\n          .catch((error) => {\n            if (typeof retryOn === \"function\") {\n              Promise.resolve(retryOn(attempt, error, null))\n                .then((retryOnResponse) => {\n                  if (retryOnResponse) {\n                    retry(attempt, error, null);\n                  } else {\n                    reject(error);\n                  }\n                })\n                .catch(reject);\n            } else if (attempt < retries) {\n              retry(attempt, error, null);\n            } else {\n              reject(error);\n            }\n          });\n      };\n\n      const retry = (\n        attempt: number,\n        error: Error | null,\n        response: Response | null,\n      ) => {\n        const delay =\n          typeof retryDelay === \"function\"\n            ? retryDelay(attempt, error, response, input)\n            : retryDelay;\n        setTimeout(() => {\n          wrappedFetch(++attempt);\n        }, delay);\n      };\n\n      wrappedFetch(0);\n    });\n  }\n}\n\nclass ArgumentError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"ArgumentError\";\n  }\n}\n\nexport default FetchClient;\n","import FetchClient from \"./fetchClient\";\n\nconst TOO_MANY_REQUESTS = 429;\nconst INTERNAL_SERVER_ERROR = 500;\nconst UNAUTHORIZED = 401;\n\ninterface HttpClientOptions {\n  apiKey: string;\n  baseURL: string;\n}\n\n/**\n * The HttpClient provides methods to perform HTTP requests.\n * The `fetch` method is used to make a request to a specified endpoint.\n * It includes retry logic for transient errors, where it will retry the request\n * according to the `maxRetries` and `retryDelay` parameters.\n * For non-transient errors, it will fail fast and not retry the request.\n * @param input - The endpoint to which the request will be made.\n * @param init - The request options.\n * @param maxRetries - The maximum number of retries for the request.\n * @param retryDelay - The delay between retries.\n * @returns A promise that resolves to the response of the request, or rejects\n *          with an error if the request fails or all retries are exhausted.\n */\nexport class HttpClient {\n  apiKey: string;\n  baseURL: string;\n  fetchClient: FetchClient;\n  debug: boolean = false;\n  retries: number = 3;\n\n  constructor(opts: HttpClientOptions) {\n    this.apiKey = opts.apiKey;\n    this.baseURL = this.sanitizeBaseUrl(opts.baseURL);\n    this.fetchClient = new FetchClient();\n    this.debug = process.env.NODE_ENV === \"development\";\n  }\n\n  /**\n   * Sanitizes the base URL by trimming whitespace and removing trailing slashes.\n   * @param baseURL - The base URL to sanitize.\n   * @returns The sanitized base URL.\n   */\n  private sanitizeBaseUrl(baseURL: string): string {\n    return baseURL.trim().replace(/\\/$/, \"\");\n  }\n\n  async fetch(\n    input: string,\n    init?: RequestInit | undefined,\n  ): Promise<Response> {\n    const url = this.baseURL + input;\n\n    const requestInit = {\n      ...init,\n      headers: {\n        ...init?.headers,\n        \"Content-Type\": init?.headers?.[\"Content-Type\"] ?? \"application/json\",\n        authorization: `Bearer ${this.apiKey}`,\n      },\n    };\n\n    const isDebug = this.debug;\n\n    if (isDebug) {\n      console.debug(\n        `\\nFetching URL: ${url}` +\n          `\\nMethod: ${requestInit.method || \"GET\"}` +\n          `${requestInit.body ? `\\nBody: ${requestInit.body}` : \"\"}` +\n          `\\nHeaders: ${JSON.stringify(requestInit.headers, null, 2)}`,\n      );\n    }\n\n    const numRetries = this.retries;\n    const resp = await this.fetchClient.fetchRetry(url, {\n      ...requestInit,\n      retryOn: function (attempt, error, response) {\n        if (attempt >= numRetries) return false;\n\n        // Retry on too many requests, internal server error, or TypeError\n        const status = response?.status;\n\n        return (\n          error instanceof TypeError ||\n          status === TOO_MANY_REQUESTS ||\n          (status !== undefined && status >= INTERNAL_SERVER_ERROR)\n        );\n      },\n      retryDelay: function (attempt, error, response, input) {\n        console.warn(\n          `Fetch attempt #${attempt}: input=${input}, error=${error?.message}, response status=${response?.status}, response status text=${response?.statusText}`,\n        );\n        return Math.pow(2, attempt) * 1000;\n      },\n    });\n\n    if (resp.status === UNAUTHORIZED) {\n      throw new Error(\n        `Unauthorized. Please check that your HAMMING_API_KEY is correct by visiting: ${this.baseURL}/settings`,\n      );\n    }\n\n    if (isDebug) {\n      console.debug(`Response for ${url}: ${resp.status} ${resp.statusText}\\n`);\n    }\n\n    return resp;\n  }\n}\n","export class ManualResetEvent {\n  private isSet: boolean;\n  private waiters: Array<(...args: any) => void>;\n\n  constructor(isSet = false) {\n    this.isSet = isSet;\n    this.waiters = [];\n    if (isSet) {\n      this.resolveWaiters();\n    }\n  }\n\n  set() {\n    this.isSet = true;\n    this.resolveWaiters();\n  }\n\n  reset() {\n    this.isSet = false;\n  }\n\n  wait() {\n    if (this.isSet) {\n      return Promise.resolve();\n    }\n    return new Promise((resolve) => {\n      this.waiters.push(resolve);\n    });\n  }\n\n  resolveWaiters() {\n    this.waiters.forEach((resolve) => resolve());\n    this.waiters = [];\n  }\n}\n","import type { Hamming } from \"./index\";\nimport { LogMessage } from \"./types\";\nimport { ManualResetEvent } from \"./utils/manualResetEvent\";\n\nconst LOG_BATCH_SIZE = 512;\n\nexport class Logger {\n  private client: Hamming;\n\n  private queue: LogMessage[] = [];\n  private stopped: boolean = false;\n  private queueHasMessages = new ManualResetEvent();\n\n  constructor(client: Hamming) {\n    this.client = client;\n  }\n\n  log(message: LogMessage): void {\n    this.queue.push(message);\n    this.queueHasMessages.set();\n  }\n\n  async start(): Promise<void> {\n    console.log(\"Starting logger thread..\");\n    while (!this.stopped) {\n      await this.queueHasMessages.wait();\n      await this._processQueue();\n    }\n    await this._processQueue();\n    console.log(\"Logger thread exited!\");\n  }\n\n  stop(): void {\n    console.log(\"Waiting for logger thread to exit..\");\n    this.stopped = true;\n  }\n\n  private _drainQueue(): LogMessage[] {\n    const batchSize = Math.min(this.queue.length, LOG_BATCH_SIZE);\n    const drainedMessages = this.queue.splice(0, batchSize);\n    return drainedMessages;\n  }\n\n  private async _processQueue(): Promise<void> {\n    const messages = this._drainQueue();\n    await this._publish(messages);\n    // TODO: test and set\n    if (this.queue.length === 0) {\n      this.queueHasMessages.reset();\n    }\n  }\n\n  private async _publish(logs: LogMessage[]): Promise<void> {\n    if (logs.length === 0) {\n      return;\n    }\n    if (process.env.NODE_ENV === \"development\") {\n      console.log(`Publishing ${logs.length} message(s)..`);\n    }\n    try {\n      await this.client.fetch(\"/logs\", {\n        method: \"POST\",\n        body: JSON.stringify({ logs }),\n      });\n      if (process.env.NODE_ENV === \"development\") {\n        console.log(`Published ${logs.length} messages!`);\n      }\n    } catch (e) {\n      console.error(`Failed to publish messages: ${e}`);\n    }\n  }\n}\n","import { ChatMessage, PromptContent } from \"./types\";\n\nexport class PromptTemplate {\n  readonly prompt: PromptContent;\n  readonly vars: Array<string>;\n\n  constructor(prompt: PromptContent) {\n    this.prompt = prompt;\n    this.vars = this.extractVariables(prompt.chatMessages ?? []);\n  }\n\n  private extractVariables(messages: ChatMessage[]): string[] {\n    const content = messages.map((message) => message.content).join(\"\\n\\n\");\n    const matches = content.match(/\\{\\{([^}]+)\\}\\}/g) ?? [];\n    return matches.map((match) => match.replace(/\\{\\{([^}]+)\\}\\}/g, \"$1\"));\n  }\n\n  compile(values: Record<string, string>): PromptContent {\n    return {\n      ...this.prompt,\n      chatMessages: this.prompt.chatMessages.map((message) => {\n        return {\n          ...message,\n          content: message.content.replace(\n            /\\{\\{([^}]+)\\}\\}/g,\n            (match, pattern) => {\n              return values[pattern] || match;\n            },\n          ),\n        };\n      }),\n    };\n  }\n}\n","import type {\n  MessageCreateParams,\n  MessageCreateParamsNonStreaming,\n  MessageParam,\n  Tool,\n} from \"@anthropic-ai/sdk/resources/messages.mjs\";\nimport { ChatMessage, PromptContent, ToolChoice } from \"../types\";\n\nexport const DEFAULT_ANTHROPIC_MAX_TOKENS = 4096;\n\nexport function convertAnthropicToolChoice(\n  input: ToolChoice,\n):\n  | MessageCreateParams.ToolChoiceAuto\n  | MessageCreateParams.ToolChoiceAny\n  | MessageCreateParams.ToolChoiceTool {\n  switch (input.choice) {\n    case \"auto\":\n      return { type: \"auto\" };\n    case \"any\":\n      return { type: \"any\" };\n    case \"tool\":\n      return { type: \"tool\", name: input.functionName ?? \"\" };\n    default:\n      throw new Error(\"Invalid tool choice type\");\n  }\n}\n\nexport function convertChatMessage(message: ChatMessage): MessageParam {\n  switch (message.role) {\n    case \"user\":\n      return {\n        role: \"user\",\n        content: message.content,\n      };\n    case \"assistant\":\n      return {\n        role: \"assistant\",\n        content: message.content,\n      };\n    default:\n      throw new Error(`Unsupported role: ${message.role}`);\n  }\n}\n\nexport function createMessageParams(\n  content: PromptContent,\n): MessageCreateParamsNonStreaming {\n  const systemMessage = content.chatMessages.find(\n    (message) => message.role === \"system\",\n  );\n  const messages = content.chatMessages.filter(\n    (message) => message.role !== \"system\",\n  );\n  return {\n    model: content.languageModel,\n    system: systemMessage?.content,\n    messages: messages.map(convertChatMessage),\n    max_tokens:\n      content.promptSettings.maxTokens ?? DEFAULT_ANTHROPIC_MAX_TOKENS,\n    top_p: content.promptSettings.topP,\n    temperature: content.promptSettings.temperature,\n    tools: content.tools ? (JSON.parse(content.tools) as Tool[]) : undefined,\n    tool_choice:\n      content.promptSettings.toolChoice && content.tools\n        ? convertAnthropicToolChoice(content.promptSettings.toolChoice)\n        : undefined,\n  };\n}\n","import type { Anthropic } from \"@anthropic-ai/sdk\";\nimport type {\n  Message,\n  RawMessageStreamEvent,\n} from \"@anthropic-ai/sdk/resources/messages.mjs\";\nimport type { Stream } from \"@anthropic-ai/sdk/streaming.mjs\";\nimport { Hamming } from \"../client\";\nimport { PromptTemplate } from \"../prompt-template\";\nimport { PromptWithContent } from \"../types\";\nimport { createMessageParams } from \"./anthropic\";\n\nclass AnthropicClient {\n  private anthropic?: Anthropic;\n\n  constructor(private readonly client: Hamming) {}\n\n  async load(): Promise<Anthropic> {\n    if (this.anthropic) {\n      return this.anthropic;\n    }\n    if (!this.client.anthropicApiKey) {\n      throw new Error(\"Anthropic API key is not set\");\n    }\n    const module = await import(\"@anthropic-ai/sdk\");\n    this.anthropic = new module.Anthropic({\n      apiKey: this.client.anthropicApiKey,\n    });\n    return this.anthropic;\n  }\n\n  async createMessage(\n    prompt: PromptWithContent,\n    variables?: Record<string, string>,\n  ): Promise<Message> {\n    if (!prompt.content) {\n      throw new Error(\"Prompt content is not set\");\n    }\n    const template = new PromptTemplate(prompt.content);\n    const content = template.compile(variables || {});\n\n    const client = await this.load();\n    const params = createMessageParams(content);\n\n    return client.messages.create({\n      ...params,\n      stream: false,\n    });\n  }\n\n  async createMessageStream(\n    prompt: PromptWithContent,\n    variables?: Record<string, string>,\n  ): Promise<Stream<RawMessageStreamEvent>> {\n    if (!prompt.content) {\n      throw new Error(\"Prompt content is not set\");\n    }\n    const template = new PromptTemplate(prompt.content);\n    const content = template.compile(variables || {});\n\n    const client = await this.load();\n    const params = createMessageParams(content);\n\n    return client.messages.create({\n      ...params,\n      stream: true,\n    });\n  }\n}\n\nexport default AnthropicClient;\n","import type { AnthropicBedrock } from \"@anthropic-ai/bedrock-sdk\";\nimport type {\n  Message,\n  RawMessageStreamEvent,\n} from \"@anthropic-ai/sdk/resources/messages.mjs\";\nimport type { Stream } from \"@anthropic-ai/sdk/streaming.mjs\";\nimport { Hamming } from \"../client\";\nimport { PromptTemplate } from \"../prompt-template\";\nimport { PromptWithContent } from \"../types\";\nimport { createMessageParams } from \"./anthropic\";\n\nclass AnthropicBedrockClient {\n  private anthropic?: AnthropicBedrock;\n\n  constructor(private readonly client: Hamming) {}\n\n  async load(): Promise<AnthropicBedrock> {\n    if (this.anthropic) {\n      return this.anthropic;\n    }\n    if (!this.client.bedrock) {\n      // We're relying on ~/.aws/credentials or AWS_SECRET_ACCESS_KEY and AWS_ACCESS_KEY_ID env vars\n      console.log(\n        \"Anthropic Bedrock config is not set. Using environment credentials.\",\n      );\n    }\n    const module = await import(\"@anthropic-ai/bedrock-sdk\");\n    this.anthropic = new module.AnthropicBedrock({\n      awsSecretKey: this.client.bedrock?.awsSecretKey,\n      awsAccessKey: this.client.bedrock?.awsAccessKey,\n      awsRegion: this.client.bedrock?.awsRegion,\n      awsSessionToken: this.client.bedrock?.awsSessionToken,\n    });\n    return this.anthropic;\n  }\n\n  async createMessage(\n    prompt: PromptWithContent,\n    variables?: Record<string, string>,\n  ): Promise<Message> {\n    if (!prompt.content) {\n      throw new Error(\"Prompt content is not set\");\n    }\n    const template = new PromptTemplate(prompt.content);\n    const content = template.compile(variables || {});\n\n    const client = await this.load();\n    const params = createMessageParams(content);\n\n    return client.messages.create({\n      ...params,\n      stream: false,\n    });\n  }\n\n  async createMessageStream(\n    prompt: PromptWithContent,\n    variables?: Record<string, string>,\n  ): Promise<Stream<RawMessageStreamEvent>> {\n    if (!prompt.content) {\n      throw new Error(\"Prompt content is not set\");\n    }\n    const template = new PromptTemplate(prompt.content);\n    const content = template.compile(variables || {});\n\n    const client = await this.load();\n    const params = createMessageParams(content);\n\n    return client.messages.create({\n      ...params,\n      stream: true,\n    });\n  }\n}\n\nexport default AnthropicBedrockClient;\n","import type { Hamming } from \"../client\";\nimport type {\n  Dataset,\n  DatasetId,\n  DatasetWithItems,\n  CreateDatasetOptions,\n} from \"../types\";\n\nexport class Datasets {\n  private client: Hamming;\n\n  constructor(client: Hamming) {\n    this.client = client;\n  }\n\n  async load(id: DatasetId): Promise<DatasetWithItems> {\n    const resp = await this.client.fetch(`/datasets/${id}`, {\n      method: \"GET\",\n    });\n\n    let data: { dataset: DatasetWithItems };\n    try {\n      data = await resp.json();\n    } catch (error) {\n      throw new Error(\n        `Failed to parse dataset response as JSON for dataset ID: ${id}: ${error}`,\n      );\n    }\n    return data.dataset as DatasetWithItems;\n  }\n\n  async list(): Promise<Dataset[]> {\n    const resp = await this.client.fetch(`/datasets`);\n    const data = await resp.json();\n    return data.datasets as Dataset[];\n  }\n\n  async create(opts: CreateDatasetOptions): Promise<DatasetWithItems> {\n    const { name, description, items } = opts;\n    const resp = await this.client.fetch(\"/datasets\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        name,\n        description,\n        items,\n      }),\n    });\n    const data = await resp.json();\n    return data.dataset as DatasetWithItems;\n  }\n}\n","import { AsyncLocalStorage } from \"node:async_hooks\";\n\nimport { RunContext } from \"./types\";\n\nexport const asyncRunContext = new AsyncLocalStorage<RunContext>();\n","export enum ScoreType {\n  AccuracyAI = \"accuracy_ai\",\n  FactsCompare = \"facts_compare\",\n  ContextRecall = \"context_recall\",\n  ContextPrecision = \"context_precision\",\n  Hallucination = \"hallucination\",\n  StringDiff = \"string_diff\",\n  Refusal = \"refusal\",\n  SqlAst = \"sql_ast\",\n}\n\nexport type InputType = Record<string, any>;\nexport type OutputType = Record<string, any>;\nexport type MetadataType = Record<string, any>;\n\nexport enum ExperimentStatus {\n  CREATED = \"CREATED\",\n  RUNNING = \"RUNNING\",\n  SCORING = \"SCORING\",\n  SCORING_FAILED = \"SCORING_FAILED\",\n  FINISHED = \"FINISHED\",\n  FAILED = \"FAILED\",\n}\n\nexport interface Experiment {\n  id: string;\n  name: string;\n  description?: string | null;\n  datasetId: number;\n  datasetVersionId?: number;\n  status: ExperimentStatus;\n}\n\nexport interface ExperimentItemMetrics {\n  durationMs?: number;\n}\n\nexport interface ExperimentItem {\n  id: string;\n  experimentId: string;\n  datasetItemId: string;\n  output: OutputType;\n  metrics: ExperimentItemMetrics;\n}\n\nexport interface ExperimentItemContext {\n  item: ExperimentItem;\n  startTs: number;\n}\n\nexport type DatasetId = string;\n\nexport interface DatasetItemValue {\n  input: InputType;\n  output: OutputType;\n  metadata: MetadataType;\n}\n\nexport type DatasetItem = DatasetItemValue & { id: string };\n\nexport interface Dataset {\n  id: string;\n  name: string;\n  description?: string;\n}\n\nexport type DatasetWithItems = Dataset & { items: DatasetItem[] };\n\nexport interface RunOptions {\n  dataset: DatasetId;\n  name?: string;\n  scoring?: (ScoreType | ScoringFunction)[];\n  metadata?: MetadataType;\n  parallel?: boolean | number;\n  sampling?: number;\n}\n\ninterface TracingContext {\n  experiment?: {\n    itemId?: string;\n  };\n  monitoring?: {\n    seqId?: number;\n  };\n}\n\nexport type RunContext = {\n  tracing: TracingContext;\n};\n\nexport type Runner = (input: InputType) => Promise<OutputType>;\n\nexport interface ClientOptions {\n  apiKey: string;\n  baseURL?: string;\n  openaiApiKey?: string;\n  anthropicApiKey?: string;\n  bedrock?: {\n    awsAccessKey?: string;\n    awsSecretKey?: string;\n    awsRegion?: string;\n    awsSessionToken?: string;\n  };\n}\n\nexport interface CreateDatasetOptions {\n  name: string;\n  description?: string;\n  items: DatasetItemValue[];\n}\n\nexport type TraceEvent = Record<string, unknown>;\n\nexport type LLMProvider = \"openai\" | \"anthropic\" | \"azure_openai\";\n\nexport interface GenerationMetadata {\n  provider?: LLMProvider;\n  model?: string;\n  stream?: boolean;\n  max_tokens?: number;\n  n?: number;\n  seed?: number;\n  temperature?: number;\n  usage?: {\n    completion_tokens?: number;\n    prompt_tokens?: number;\n    total_tokens?: number;\n  };\n  duration_ms?: number;\n  error?: boolean;\n  error_message?: string;\n}\n\nexport interface GenerationParams {\n  input?: string;\n  output?: string;\n  metadata?: GenerationMetadata;\n}\n\nexport interface Document {\n  pageContent: string;\n  metadata: Record<string, any>;\n}\n\nexport interface RetrievalParams {\n  query?: string;\n  results?: Document[] | string[];\n  metadata?: {\n    engine?: string;\n    [key: string]: unknown;\n  };\n}\n\nexport interface Trace {\n  id: number;\n  experimentItemId: string;\n  parentId?: number;\n  event: TraceEvent;\n}\n\nexport enum TracingMode {\n  OFF = \"off\",\n  MONITORING = \"monitoring\",\n  EXPERIMENT = \"experiment\",\n}\n\nexport interface ITracing {\n  logGeneration(params: GenerationParams): void;\n  logRetrieval(params: RetrievalParams): void;\n  log(key: string, value: unknown): void;\n  log(trace: TraceEvent): void;\n}\n\nexport interface MonitoringItem {\n  setInput(input: InputType): void;\n  setOutput(output: OutputType): void;\n  setMetadata(metadata: MetadataType): void;\n  end(error?: boolean, errorMessage?: string): void;\n  tracing: ITracing;\n}\n\nexport enum MonitoringItemStatus {\n  STARTED = \"STARTED\",\n  COMPLETED = \"COMPLETED\",\n  FAILED = \"FAILED\",\n}\n\nexport enum SessionEnvironment {\n  DEVELOPMENT = \"development\",\n  STAGING = \"staging\",\n  PRODUCTION = \"production\",\n}\n\nexport interface MonitoringStartOpts {\n  environment?: SessionEnvironment;\n}\n\nexport interface MonitoringSession {\n  id: string;\n  seqId: number;\n}\n\nexport interface MonitoringTraceContext {\n  session_id: string;\n  seq_id: number;\n  parent_seq_id?: number;\n}\n\nexport interface MonitoringTrace extends MonitoringTraceContext {\n  event: TraceEvent;\n}\n\nexport enum LogMessageType {\n  MONITORING = 1,\n}\n\nexport interface LogMessage {\n  type: LogMessageType;\n  payload?: MonitoringTrace;\n}\n\nexport interface Score {\n  value: number;\n  reason?: string;\n}\n\nexport enum FunctionType {\n  Numeric = \"numeric\",\n  Classification = \"classification\",\n}\n\nexport type NumericScoreConfig = {\n  type: FunctionType.Numeric;\n  aggregate: \"mean\" | \"median\";\n};\n\nexport type ClassificationScoreConfig = {\n  type: FunctionType.Classification;\n  labels: Record<number, string>;\n  colors?: Record<number, LabelColor>;\n};\n\nexport type ScoreConfig = ClassificationScoreConfig | NumericScoreConfig;\n\nexport enum ScorerExecutionType {\n  Local = \"local\",\n  Remote = \"remote\",\n}\n\ntype Scorer = LocalScorer | LLMClassifyScorer;\n\nexport interface LocalScorer {\n  type: ScorerExecutionType.Local;\n  scoreFn: (args: {\n    input: InputType;\n    output: OutputType;\n    expected: OutputType;\n  }) => Promise<Score>;\n}\n\ninterface RemoteScorer {\n  type: ScorerExecutionType.Remote;\n}\n\ninterface PromptConfig {\n  slug: string;\n  label?: string;\n}\n\nexport enum ScoreParserType {\n  XML = \"xml\",\n  JSON = \"json\",\n}\n\ninterface ScoreParserConfig {\n  type: ScoreParserType;\n}\n\nexport interface LLMClassifyScorer extends RemoteScorer {\n  method: \"classify\";\n  prompt: PromptConfig;\n  variableMappings?: Record<string, string>;\n  scoreParser: ScoreParserConfig;\n}\n\nexport interface ScoringFunction {\n  name: string;\n  version: number;\n  scoreConfig?: ScoreConfig;\n  scorer: Scorer;\n}\n\nexport interface CustomScoringConfig {\n  id: string;\n  key_name: string;\n}\n\nexport const ScoringErrorValue = -1;\n\nexport const ScoringErrorPrefix = \"<!--hamming_scoring_error-->\";\n\nexport enum LabelColor {\n  Gray = \"gray\",\n  LightGreen = \"light-green\",\n  LightBlue = \"light-blue\",\n  Amber = \"amber\",\n  Purple = \"purple\",\n  Pink = \"pink\",\n  Green = \"green\",\n  PastelGreen = \"pastel-green\",\n  Yellow = \"yellow\",\n  Blue = \"blue\",\n  Red = \"red\",\n}\n\nexport interface Prompt {\n  slug: string;\n}\n\nexport interface ToolChoice {\n  choice: string;\n  functionName: string;\n}\n\nexport interface PromptSettings {\n  temperature?: number;\n  maxTokens?: number;\n  topP?: number;\n  frequencyPenalty?: number;\n  presencePenalty?: number;\n  toolChoice?: ToolChoice;\n}\n\nexport interface ChatMessage {\n  role: string;\n  content: string;\n}\n\nexport interface PromptContent {\n  languageModel: string;\n  promptSettings: PromptSettings;\n  chatMessages: ChatMessage[];\n  tools?: string;\n}\n\nexport interface PromptWithContent extends Prompt {\n  content?: PromptContent;\n}\n","const MAX_WORKERS = 100;\n\nexport async function runWorkers<T>(\n  workItems: T[],\n  runFn: (workItem: T) => Promise<void>,\n  count: number = MAX_WORKERS,\n) {\n  const iterator = workItems.entries();\n  const workerCount = Math.min(count, workItems.length, MAX_WORKERS);\n  const workers = Array(workerCount)\n    .fill(iterator)\n    .map(async (iterator, idx) => {\n      for (const [index, workItem] of iterator) {\n        if (process.env.NODE_ENV === \"development\") {\n          console.log(`Worker ${idx} is processing task ${index}`);\n        }\n        await runFn(workItem);\n        if (process.env.NODE_ENV === \"development\") {\n          console.log(`Worker ${idx} has finished task ${index}`);\n        }\n      }\n    });\n  await Promise.all(workers);\n}\n","import { asyncRunContext } from \"../asyncStorage\";\nimport type { Hamming } from \"../client\";\nimport {\n  CustomScoringConfig,\n  DatasetId,\n  DatasetItem,\n  Experiment,\n  ExperimentItem,\n  ExperimentItemContext,\n  ExperimentStatus,\n  InputType,\n  LocalScorer,\n  MetadataType,\n  OutputType,\n  RunContext,\n  Runner,\n  RunOptions,\n  Score,\n  ScorerExecutionType,\n  ScoreType,\n  ScoringErrorPrefix,\n  ScoringErrorValue,\n  ScoringFunction,\n  TracingMode,\n} from \"../types\";\nimport { runWorkers } from \"../worker\";\n\nconst MAX_SAMPLES = 10;\n\nfunction newRunContext(itemId: string): RunContext {\n  return {\n    tracing: {\n      experiment: {\n        itemId,\n      },\n    },\n  };\n}\n\nconst defaultScoreTypes = [ScoreType.StringDiff];\n\ninterface RegisteredScoringFunction extends ScoringFunction {\n  registration: CustomScoringConfig;\n}\n\nclass ExperimentItems {\n  private client: Hamming;\n\n  constructor(client: Hamming) {\n    this.client = client;\n  }\n\n  async start(\n    experiment: Experiment,\n    datasetItem: DatasetItem,\n    sampleId?: number,\n  ): Promise<ExperimentItemContext> {\n    const resp = await this.client.fetch(\n      `/experiments/${experiment.id}/items`,\n      {\n        method: \"POST\",\n        body: JSON.stringify({\n          datasetItemId: datasetItem.id,\n          output: {},\n          metrics: {},\n          sampleId,\n        }),\n      },\n    );\n    const data = await resp.json();\n    const item = data.item as ExperimentItem;\n\n    const startTs = Date.now();\n    return {\n      item,\n      startTs,\n    };\n  }\n\n  async end(\n    itemContext: ExperimentItemContext,\n    output: OutputType,\n    scores: Record<string, Score> = {},\n    failed: boolean = false,\n  ) {\n    const { item, startTs } = itemContext;\n    const durationMs = Date.now() - startTs;\n    await this.client.tracing._flush(item.id);\n    // Completing the experiment item should happen after the traces are\n    // flushed, since it will automatically trigger scoring.\n    await this.client.fetch(\n      `/experiments/${item.experimentId}/items/${item.id}`,\n      {\n        method: \"PATCH\",\n        body: JSON.stringify({\n          output,\n          scores,\n          metrics: {\n            durationMs,\n          },\n          failed,\n        }),\n      },\n    );\n  }\n}\n\nexport class Experiments {\n  private client: Hamming;\n  private items: ExperimentItems;\n\n  constructor(client: Hamming) {\n    this.client = client;\n    this.items = new ExperimentItems(this.client);\n  }\n\n  async run(opts: RunOptions, run: Runner) {\n    const { dataset: datasetId } = opts;\n    const dataset = await this.client.datasets.load(datasetId);\n\n    this.client.tracing._setMode(TracingMode.EXPERIMENT);\n\n    const {\n      name = this.generateName(dataset.name),\n      scoring = defaultScoreTypes,\n      metadata = {},\n      sampling,\n    } = opts;\n\n    const sampleCount = sampling ?? 1;\n    if (sampleCount > MAX_SAMPLES) {\n      throw new Error(`The maximum number of samples is ${MAX_SAMPLES}.`);\n    }\n\n    const scoringHelper = new ScoringHelper(this.client, scoring);\n    await scoringHelper.initialize();\n\n    const experiment = await this.start(\n      name,\n      datasetId,\n      scoringHelper.getConfig(),\n      metadata,\n      sampling,\n    );\n    const baseUrl = new URL(this.client.baseURL);\n    const experimentUrl = `${baseUrl.origin}/experiments/${experiment.id}`;\n\n    try {\n      for (let sampleId = 0; sampleId < sampleCount; sampleId++) {\n        if (opts.parallel) {\n          const runFn = async (datasetItem: DatasetItem) => {\n            const itemCtx = await this.items.start(\n              experiment,\n              datasetItem,\n              sampleId,\n            );\n            try {\n              const output = await asyncRunContext.run(\n                newRunContext(itemCtx.item.id),\n                async () => run(datasetItem.input),\n              );\n              if (!output || typeof output !== \"object\") {\n                throw new Error(`Invalid output: ${output}`);\n              }\n              const scores = await scoringHelper.score(\n                datasetItem.input,\n                datasetItem.output,\n                output,\n              );\n              await this.items.end(itemCtx, output, scores);\n            } catch (err) {\n              console.error(err);\n              const msg = err instanceof Error ? err.message : \"Unknown error\";\n              const output = { error: msg };\n              await this.items.end(itemCtx, output, {}, true);\n            }\n          };\n          const workerCount =\n            typeof opts.parallel === \"number\" ? opts.parallel : undefined;\n          await runWorkers(dataset.items, runFn, workerCount);\n        } else {\n          for (const datasetItem of dataset.items) {\n            const itemCtx = await this.items.start(\n              experiment,\n              datasetItem,\n              sampleId,\n            );\n            try {\n              const output = await asyncRunContext.run(\n                newRunContext(itemCtx.item.id),\n                async () => await run(datasetItem.input),\n              );\n              if (!output || typeof output !== \"object\") {\n                throw new Error(`Invalid output: ${output}`);\n              }\n              const scores = await scoringHelper.score(\n                datasetItem.input,\n                datasetItem.output,\n                output,\n              );\n              await this.items.end(itemCtx, output, scores);\n            } catch (err) {\n              console.error(err);\n              const msg = err instanceof Error ? err.message : \"Unknown error\";\n              const output = { error: msg };\n              await this.items.end(itemCtx, output, {}, true);\n            }\n          }\n        }\n      }\n    } catch (err) {\n      await this.end(experiment, ExperimentStatus.FAILED);\n      throw err;\n    } finally {\n      await this.end(experiment);\n      console.log(\"See experiment results at:\", experimentUrl);\n    }\n    return { experimentUrl };\n  }\n\n  private async start(\n    name: string,\n    dataset: DatasetId,\n    scoring: (ScoreType | CustomScoringConfig)[],\n    metadata: MetadataType,\n    sampling?: number,\n  ): Promise<Experiment> {\n    const status = ExperimentStatus.RUNNING;\n    const resp = await this.client.fetch(`/experiments`, {\n      method: \"POST\",\n      body: JSON.stringify({\n        name,\n        dataset,\n        status,\n        scoring,\n        metadata,\n        sampling,\n      }),\n    });\n\n    const data = await resp.json();\n    return data.experiment as Experiment;\n  }\n\n  private async end(\n    experiment: Experiment,\n    status: ExperimentStatus = ExperimentStatus.FINISHED,\n  ) {\n    await this.client.fetch(`/experiments/${experiment.id}`, {\n      method: \"PATCH\",\n      body: JSON.stringify({\n        status,\n      }),\n    });\n  }\n\n  private generateName(datasetName: string): string {\n    const now = new Date();\n    return `Experiment for ${datasetName} - ${now.toLocaleString()}`;\n  }\n}\n\nclass ScoringHelper {\n  private readonly client: Hamming;\n\n  public readonly standardScoring: ScoreType[];\n  public readonly customScoring: ScoringFunction[];\n\n  private registeredFunctions: RegisteredScoringFunction[] = [];\n  private initialized = false;\n\n  constructor(client: Hamming, scoring: (ScoringFunction | ScoreType)[]) {\n    this.client = client;\n\n    this.standardScoring = scoring.filter(\n      (score): score is ScoreType => typeof score === \"string\",\n    );\n    this.customScoring = scoring.filter(\n      (score): score is ScoringFunction => typeof score !== \"string\",\n    );\n  }\n\n  async initialize() {\n    await this.registerScoringFunctions();\n    this.initialized = true;\n  }\n\n  getConfig(): (ScoreType | CustomScoringConfig)[] {\n    if (!this.initialized) {\n      throw new Error(\"ScoringHelper is not initialized\");\n    }\n    return [\n      ...this.standardScoring,\n      ...this.registeredFunctions.map((f) => f.registration),\n    ];\n  }\n\n  async score(\n    input: InputType,\n    expected: OutputType,\n    output: OutputType,\n  ): Promise<Record<string, Score>> {\n    if (!this.initialized) {\n      throw new Error(\"ScoringHelper is not initialized\");\n    }\n    const scores = {} as Record<string, Score>;\n    const promises = this.registeredFunctions\n      .filter((f) => f.scorer.type === \"local\")\n      .map(async (f) => {\n        const scorer = f.scorer as LocalScorer;\n\n        try {\n          scores[f.registration.key_name] = await scorer.scoreFn({\n            input,\n            output,\n            expected,\n          });\n        } catch (err) {\n          console.error(\n            `Failed to locally run score ${f.name.toLowerCase()}.`,\n            \"Note: This error will be displayed in the dashboard. All other scoring will be preserved and displayed accordingly.\",\n            \"Error received:\",\n            err,\n          );\n          scores[f.registration.key_name] = {\n            value: ScoringErrorValue,\n            reason: `${ScoringErrorPrefix}${err.message}`,\n          };\n        }\n      });\n    await Promise.allSettled(promises);\n    return scores;\n  }\n\n  private async registerScoringFunctions() {\n    const scoring = this.customScoring.map((scoringFunc) => ({\n      name: scoringFunc.name,\n      version: scoringFunc.version,\n      score_config: scoringFunc.scoreConfig,\n      execution_config: getExecutionConfig(scoringFunc),\n    }));\n    const resp = await this.client.fetch(`/scoring/register-functions`, {\n      method: \"POST\",\n      body: JSON.stringify({\n        scoring: scoring,\n      }),\n    });\n\n    const data = await resp.json();\n    const registrations = (data.scoring ?? []) as CustomScoringConfig[];\n    this.registeredFunctions = this.customScoring.map(\n      (scoringFunction, idx) => ({\n        ...scoringFunction,\n        registration: registrations[idx],\n      }),\n    );\n  }\n}\n\nfunction getExecutionConfig(scoringFunc: ScoringFunction): Record<string, any> {\n  if (scoringFunc.scorer.type === ScorerExecutionType.Remote) {\n    const { prompt, variableMappings, scoreParser } = scoringFunc.scorer;\n    return {\n      prompt,\n      variableMappings,\n      scoreParser,\n    };\n  }\n  return {};\n}\n","import { asyncRunContext } from \"../asyncStorage\";\nimport type { Hamming } from \"../client\";\nimport {\n  Document,\n  GenerationParams,\n  ITracing,\n  LogMessageType,\n  MonitoringTrace,\n  RetrievalParams,\n  Trace,\n  TraceEvent,\n  TracingMode,\n} from \"../types\";\n\nexport abstract class TracerBase implements ITracing {\n  abstract logEvent(event: TraceEvent): void;\n\n  private _generationEvent(params: GenerationParams): TraceEvent {\n    return {\n      kind: \"llm\",\n      ...params,\n    };\n  }\n\n  private _retrievalEvent(params: RetrievalParams): TraceEvent {\n    const isString = (item: any) => typeof item === \"string\";\n    const hasStringResults = params.results?.every(isString);\n    const normalizeResult = (result: string | Document): Document => {\n      if (typeof result === \"string\") {\n        return { pageContent: result, metadata: {} };\n      }\n      return result;\n    };\n\n    const results = hasStringResults\n      ? params.results?.map(normalizeResult)\n      : params.results;\n\n    return {\n      kind: \"vector\",\n      ...params,\n      results,\n    };\n  }\n\n  log(key: string, value: unknown): void;\n  log(trace: TraceEvent): void;\n  log(keyOrTrace: string | TraceEvent, value?: unknown): void {\n    const event = (() => {\n      const isKeyValue = typeof keyOrTrace === \"string\";\n      if (isKeyValue) {\n        const key = keyOrTrace as string;\n        const event: TraceEvent = { [key]: value };\n        return event;\n      } else {\n        const event = keyOrTrace as TraceEvent;\n        return event;\n      }\n    })();\n    this.logEvent(event);\n  }\n\n  logGeneration(params: GenerationParams): void {\n    const updatedParams: GenerationParams = {\n      ...params,\n      metadata: {\n        ...params.metadata,\n        // Error is true if either error or error_message is set, false otherwise\n        error: params.metadata?.error || !!params.metadata?.error_message,\n      },\n    };\n    this.log(this._generationEvent(updatedParams));\n  }\n\n  logRetrieval(params: RetrievalParams): void {\n    this.log(this._retrievalEvent(params));\n  }\n}\n\nexport class Tracing extends TracerBase implements ITracing {\n  private client: Hamming;\n  private collected: Record<string, TraceEvent[]> = {};\n  private currentLocalTraceId: number = 0;\n\n  private mode: TracingMode = TracingMode.OFF;\n\n  constructor(client: Hamming) {\n    super();\n    this.client = client;\n  }\n\n  _setMode(mode: TracingMode) {\n    this.mode = mode;\n  }\n\n  private nextTraceId(): number {\n    return this.currentLocalTraceId++;\n  }\n\n  async _flush(experimentItemId: string) {\n    if (this.mode !== TracingMode.EXPERIMENT) {\n      console.warn(`Tracing mode must be set to <experiment>!`);\n      return;\n    }\n\n    const events = this.collected[experimentItemId] ?? [];\n    delete this.collected[experimentItemId];\n\n    const rootTrace: Trace = {\n      id: this.nextTraceId(),\n      experimentItemId,\n      event: { kind: \"root\" },\n    };\n\n    const traces: Trace[] = [rootTrace];\n\n    for (const event of events) {\n      traces.push({\n        id: this.nextTraceId(),\n        experimentItemId,\n        parentId: rootTrace.id,\n        event,\n      });\n    }\n\n    await this.client.fetch(`/traces`, {\n      method: \"POST\",\n      body: JSON.stringify({\n        traces,\n      }),\n    });\n  }\n\n  _logLiveTrace(trace: MonitoringTrace) {\n    if (this.mode !== TracingMode.MONITORING) {\n      console.warn(`Tracing mode must be set to <monitoring>!`);\n      return;\n    }\n\n    this.client._logger.log({\n      type: LogMessageType.MONITORING,\n      payload: trace,\n    });\n  }\n\n  logEvent(event: TraceEvent) {\n    const runCtx = asyncRunContext.getStore();\n    if (this.mode === TracingMode.EXPERIMENT) {\n      const itemId = runCtx?.tracing?.experiment?.itemId;\n      if (!itemId) {\n        console.error(\"Unable to log trace event without experiment item ID.\");\n        return;\n      }\n      if (!this.collected[itemId]) {\n        this.collected[itemId] = [];\n      }\n      this.collected[itemId].push(event);\n    } else if (this.mode === TracingMode.MONITORING) {\n      const trace = this.client.monitoring._getTraceContext(runCtx);\n      if (!trace) {\n        return;\n      }\n      this._logLiveTrace({\n        event,\n        ...trace,\n      });\n    } else {\n      console.warn(\"Attempt to send a log trace, but tracing mode is off!\");\n    }\n  }\n}\n","import type {\n  Hamming,\n  MonitoringStartOpts,\n  RunContext,\n  TraceEvent,\n} from \"../index\";\n\nimport {\n  MonitoringItem as IMonitoringItem,\n  ITracing,\n  InputType,\n  MetadataType,\n  MonitoringItemStatus,\n  MonitoringSession,\n  MonitoringTrace,\n  OutputType,\n  TracingMode,\n  MonitoringTraceContext,\n} from \"../types\";\nimport { asyncRunContext } from \"../asyncStorage\";\nimport { TracerBase } from \"./tracing\";\n\nenum MonitoringState {\n  STARTED,\n  STOPPED,\n}\n\nconst INVALID_SESSION_ID = \"INVALID_SESSION\";\n\nfunction newRunContext(seqId: number): RunContext {\n  return {\n    tracing: {\n      monitoring: {\n        seqId,\n      },\n    },\n  };\n}\n\nclass MonitoringItemTracing extends TracerBase implements ITracing {\n  client: Hamming;\n  runCtx: RunContext;\n\n  constructor(client: Hamming, seqId: number) {\n    super();\n    this.client = client;\n    this.runCtx = newRunContext(seqId);\n  }\n\n  logEvent(event: TraceEvent) {\n    const trace = this.client.monitoring._getTraceContext(this.runCtx);\n    if (!trace) return;\n    this.client.tracing._logLiveTrace({\n      event,\n      ...trace,\n    });\n  }\n}\n\nclass MonitoringItem implements IMonitoringItem {\n  client: Hamming;\n  sessionId: string;\n  seqId: number;\n  input: InputType | undefined;\n  output: OutputType | undefined;\n  metadata: MetadataType | undefined;\n  metrics: Record<string, any>;\n  status: MonitoringItemStatus;\n  errorMessage: string | undefined;\n  startTs: number;\n\n  tracing: ITracing;\n\n  constructor(client: Hamming, sessionId: string, seqId: number) {\n    this.client = client;\n    this.sessionId = sessionId;\n    this.seqId = seqId;\n    this.metrics = {};\n    this.tracing = new MonitoringItemTracing(client, seqId);\n  }\n\n  setInput(input: InputType) {\n    this.input = input;\n  }\n\n  setOutput(output: OutputType) {\n    this.output = output;\n  }\n\n  setMetadata(metadata: MetadataType) {\n    this.metadata = metadata;\n  }\n\n  end(error: boolean = false, errorMessage?: string) {\n    this._end(error, errorMessage);\n  }\n\n  _start() {\n    this.startTs = Date.now();\n    this.status = MonitoringItemStatus.STARTED;\n  }\n\n  _end(error: boolean = false, errorMessage?: string) {\n    if (this._hasEnded()) return;\n\n    this.metrics.duration_ms = Date.now() - this.startTs;\n    this.status = error\n      ? MonitoringItemStatus.FAILED\n      : MonitoringItemStatus.COMPLETED;\n    this.errorMessage = errorMessage;\n    this.client.monitoring._endItem(this._toTrace());\n  }\n\n  _hasEnded() {\n    return [\n      MonitoringItemStatus.COMPLETED,\n      MonitoringItemStatus.FAILED,\n    ].includes(this.status);\n  }\n\n  _toTrace(): MonitoringTrace {\n    return {\n      session_id: this.sessionId,\n      seq_id: this.seqId,\n      parent_seq_id: undefined,\n      event: {\n        kind: \"root\",\n        input: this.input,\n        output: this.output,\n        metadata: this.metadata,\n        metrics: this.metrics,\n        status: this.status,\n        error_message: this.errorMessage,\n      },\n    };\n  }\n}\n\nexport class Monitoring {\n  client: Hamming;\n  private state: MonitoringState = MonitoringState.STOPPED;\n  private session: MonitoringSession | null;\n  private monitoringStartOpts: MonitoringStartOpts | undefined;\n\n  constructor(client: Hamming) {\n    this.client = client;\n  }\n\n  start(opts?: MonitoringStartOpts) {\n    // Delay creating session until the first async call of runItem\n    this.monitoringStartOpts = opts;\n    this.client._logger.start();\n    this.client.tracing._setMode(TracingMode.MONITORING);\n    this.state = MonitoringState.STARTED;\n    console.log(\"Monitoring started!\");\n  }\n\n  stop() {\n    this.session = null;\n    this.client.tracing._setMode(TracingMode.OFF);\n    this.client._logger.stop();\n    this.state = MonitoringState.STOPPED;\n    console.log(\"Monitoring stopped!\");\n  }\n\n  async runItem(\n    callback: (item: IMonitoringItem) => unknown | Promise<unknown>,\n  ): Promise<unknown> {\n    await this._createSessionIfNotExist();\n    const [sessionId, seqId] = this._nextSeqId();\n\n    const item = new MonitoringItem(this.client, sessionId, seqId);\n    item._start();\n\n    try {\n      const response = await asyncRunContext.run(\n        newRunContext(item.seqId),\n        async () => await callback(item),\n      );\n      if (!item.output) {\n        if (\n          response &&\n          response instanceof Object &&\n          !Array.isArray(response)\n        ) {\n          item.setOutput(response);\n        } else {\n          item.setOutput({ response });\n        }\n      }\n      item._end();\n\n      return response;\n    } catch (error) {\n      item._end(true, error.message);\n      throw error;\n    }\n  }\n\n  async startItem(): Promise<IMonitoringItem> {\n    await this._createSessionIfNotExist();\n    const [sessionId, seqId] = this._nextSeqId();\n\n    const item = new MonitoringItem(this.client, sessionId, seqId);\n    item._start();\n    return item;\n  }\n\n  _endItem(trace: MonitoringTrace) {\n    if (this.state === MonitoringState.STOPPED) {\n      return;\n    }\n    this.client.tracing._logLiveTrace(trace);\n  }\n\n  _getTraceContext(ctx?: RunContext): MonitoringTraceContext | null {\n    if (this.state === MonitoringState.STOPPED) {\n      return null;\n    }\n    if (!this.session) throw Error(\"Monitoring not started\");\n\n    const [sessionId, seqId] = this._nextSeqId();\n    const parentSeqId = ctx?.tracing?.monitoring?.seqId;\n\n    return {\n      session_id: sessionId,\n      seq_id: seqId,\n      parent_seq_id: parentSeqId,\n    };\n  }\n\n  private _nextSeqId(): [string, number] {\n    if (this.state === MonitoringState.STOPPED) {\n      return [INVALID_SESSION_ID, 0];\n    }\n    if (!this.session) {\n      throw Error(\"Monitoring not started\");\n    }\n    this.session.seqId += 1;\n    return [this.session.id, this.session.seqId];\n  }\n\n  private async _createSessionIfNotExist() {\n    if (this.state === MonitoringState.STOPPED) {\n      return;\n    }\n    if (this.session) return;\n    const environment =\n      this.monitoringStartOpts?.environment ?? process.env.NODE_ENV;\n    const resp = await this.client.fetch(\"/sessions\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        metadata: environment ? { environment } : {},\n      }),\n    });\n    const data = await resp.json();\n    this.session = {\n      id: data.id,\n      seqId: 0,\n    };\n  }\n}\n","import type OpenAI from \"openai\";\nimport type {\n  ChatCompletion,\n  ChatCompletionChunk,\n  ChatCompletionCreateParamsBase,\n  ChatCompletionToolChoiceOption,\n} from \"openai/resources/chat/completions\";\nimport type { ChatCompletionMessageParam } from \"openai/resources/index.mjs\";\nimport { Stream } from \"openai/streaming.mjs\";\n\nimport { Hamming } from \"../client\";\nimport { PromptTemplate } from \"../prompt-template\";\nimport {\n  ChatMessage,\n  GenerationMetadata,\n  PromptContent,\n  PromptWithContent,\n  ToolChoice,\n} from \"../types\";\n\nexport class OpenAIClient {\n  private openai?: OpenAI;\n\n  constructor(private readonly client: Hamming) {}\n\n  async load(): Promise<OpenAI> {\n    if (this.openai) {\n      return this.openai;\n    }\n    if (!this.client.openaiApiKey) {\n      throw new Error(\n        \"OpenAI API key not set. Initialize the Hamming client with an OpenAI API key.\",\n      );\n    }\n    const module = await import(\"openai\");\n    this.openai = new module.OpenAI({\n      apiKey: this.client.openaiApiKey,\n    });\n    return this.openai;\n  }\n\n  async createChatCompletion(\n    prompt: PromptWithContent,\n    variables?: Record<string, string>,\n  ): Promise<ChatCompletion> {\n    if (!prompt.content) {\n      throw new Error(\"Prompt content not set\");\n    }\n\n    const template = new PromptTemplate(prompt.content);\n    const content = template.compile(variables || {});\n\n    const client = await this.load();\n    const params = createChatCompletionParams(content);\n\n    const completion = await this.client.monitoring.runItem(async (item) => {\n      item.setInput(params);\n      item.setMetadata({\n        sdk: {\n          type: \"openai_prompt\",\n          stream: false,\n          prompt: {\n            slug: prompt.slug,\n          },\n          variables,\n        },\n      });\n      const meta: GenerationMetadata = {\n        model: params.model,\n        stream: false,\n        temperature: params.temperature ?? undefined,\n        max_tokens: params.max_tokens ?? undefined,\n        n: params.n ?? undefined,\n        seed: params.seed ?? undefined,\n      };\n      try {\n        const completion = await client.chat.completions.create({\n          ...params,\n          stream: false,\n        });\n        item.tracing.logGeneration({\n          input: JSON.stringify(params),\n          output: JSON.stringify(completion),\n          metadata: {\n            ...meta,\n            usage: completion.usage,\n          },\n        });\n        item.setOutput(completion);\n        return completion;\n      } catch (e) {\n        item.tracing.logGeneration({\n          input: JSON.stringify(params),\n          metadata: {\n            ...meta,\n            error: true,\n            error_message: (e as Error).message,\n          },\n        });\n        throw e;\n      }\n    });\n    return completion as ChatCompletion;\n  }\n\n  async createChatCompletionStream(\n    prompt: PromptWithContent,\n    variables?: Record<string, string>,\n  ): Promise<Stream<ChatCompletionChunk>> {\n    if (!prompt.content) {\n      throw new Error(\"Prompt content not set\");\n    }\n    const template = new PromptTemplate(prompt.content);\n    const content = template.compile(variables || {});\n\n    const client = await this.load();\n    const params = createChatCompletionParams(content);\n\n    const item = await this.client.monitoring.startItem();\n    item.setInput(params);\n    item.setMetadata({\n      sdk: {\n        type: \"openai_prompt\",\n        stream: true,\n        prompt: {\n          slug: prompt.slug,\n        },\n        variables,\n      },\n    });\n\n    const meta: GenerationMetadata = {\n      model: params.model,\n      stream: true,\n      temperature: params.temperature ?? undefined,\n      max_tokens: params.max_tokens ?? undefined,\n      n: params.n ?? undefined,\n      seed: params.seed ?? undefined,\n    };\n\n    try {\n      const original = await client.chat.completions.create({\n        ...params,\n        stream: true,\n      });\n      const stream = new Stream<ChatCompletionChunk>(async function* () {\n        const chunks: ChatCompletionChunk[] = [];\n        for await (const chunk of original) {\n          chunks.push(chunk);\n          yield chunk;\n        }\n        const lastChunk = chunks.length > 0 ? chunks[chunks.length - 1] : null;\n        item.tracing.logGeneration({\n          input: JSON.stringify(params),\n          output: JSON.stringify({ chunks }),\n          metadata: {\n            ...meta,\n            usage: lastChunk?.usage,\n          },\n        });\n        item.setOutput({ chunks });\n        item.end();\n      }, original.controller);\n      return stream;\n    } catch (e) {\n      item.tracing.logGeneration({\n        input: JSON.stringify(params),\n        metadata: {\n          ...meta,\n          error: true,\n          error_message: (e as Error).message,\n        },\n      });\n      item.end(true, (e as Error).message);\n      throw e;\n    } finally {\n    }\n  }\n}\n\nfunction createChatCompletionParams(\n  content: PromptContent,\n): ChatCompletionCreateParamsBase {\n  return {\n    model: content.languageModel,\n    messages: content.chatMessages.map((m) => convertChatMessage(m)),\n    temperature: content.promptSettings.temperature,\n    max_tokens: content.promptSettings.maxTokens,\n    top_p: content.promptSettings.topP,\n    frequency_penalty: content.promptSettings.frequencyPenalty,\n    presence_penalty: content.promptSettings.presencePenalty,\n    tool_choice:\n      content.promptSettings.toolChoice && content.tools\n        ? convertToolChoice(content.promptSettings.toolChoice)\n        : undefined,\n    tools: content.tools ? JSON.parse(content.tools) : undefined,\n  };\n}\n\nfunction convertChatMessage(message: ChatMessage): ChatCompletionMessageParam {\n  switch (message.role) {\n    case \"system\":\n      return { role: \"system\", content: message.content };\n    case \"user\":\n      return { role: \"user\", content: message.content };\n    case \"assistant\":\n      return { role: \"assistant\", content: message.content };\n    default:\n      throw new Error(`Unsupported message role: ${message.role}`);\n  }\n}\n\nfunction convertToolChoice(\n  toolChoice: ToolChoice,\n): ChatCompletionToolChoiceOption {\n  switch (toolChoice.choice) {\n    case \"none\":\n      return \"none\";\n    case \"auto\":\n      return \"auto\";\n    case \"function\":\n      return {\n        type: \"function\",\n        function: {\n          name: toolChoice.functionName,\n        },\n      };\n    default:\n      throw new Error(`Unsupported tool choice: ${toolChoice.choice}`);\n  }\n}\n\nexport default OpenAIClient;\n","import type { Hamming } from \"../client\";\nimport { Prompt, PromptWithContent } from \"../types\";\n\ninterface ListPromptsResponse {\n  prompts: Prompt[];\n}\n\ninterface GetPromptResponse {\n  prompt: PromptWithContent;\n}\n\nexport class Prompts {\n  constructor(private readonly client: Hamming) {}\n\n  async list(label?: string): Promise<Prompt[]> {\n    let url = \"/prompts\";\n    if (label) {\n      url += `?label=${label}`;\n    }\n    const resp = await this.client.fetch(url);\n    const prompts = (await resp.json()) as ListPromptsResponse;\n    return prompts.prompts;\n  }\n\n  async get(\n    slug: string,\n    label?: string,\n    version?: string,\n  ): Promise<PromptWithContent> {\n    let url = `/prompts/${slug}`;\n    if (label) {\n      url += `?label=${label}`;\n    }\n    if (version) {\n      url += `&version=${version}`;\n    }\n    const resp = await this.client.fetch(url);\n    const prompt = (await resp.json()) as GetPromptResponse;\n    return prompt.prompt;\n  }\n}\n","import { HttpClient } from \"./httpClient\";\nimport { Logger } from \"./logger\";\nimport AnthropicClient from \"./resources/anthropic-client\";\nimport AnthropicBedrockClient from \"./resources/anthropic-bedrock-client\";\nimport { Datasets } from \"./resources/datasets\";\nimport { Experiments } from \"./resources/experiments\";\nimport { Monitoring } from \"./resources/monitoring\";\nimport OpenAIClient from \"./resources/openai-client\";\nimport { Prompts } from \"./resources/prompts\";\nimport { Tracing } from \"./resources/tracing\";\nimport { ClientOptions } from \"./types\";\n\nconst CLIENT_OPTIONS_KEYS: (keyof ClientOptions)[] = [\n  \"apiKey\",\n  \"baseURL\",\n  \"openaiApiKey\",\n  \"anthropicApiKey\",\n  \"bedrock\",\n];\n\nexport class Hamming extends HttpClient {\n  openaiApiKey?: string;\n  anthropicApiKey?: string;\n  bedrock?: {\n    awsSecretKey?: string;\n    awsAccessKey?: string;\n    awsRegion?: string;\n    awsSessionToken?: string;\n  };\n\n  constructor(config: ClientOptions) {\n    const unexpectedConfigKeys = Object.keys(config).filter(\n      (key) => !CLIENT_OPTIONS_KEYS.includes(key as keyof ClientOptions),\n    );\n\n    if (unexpectedConfigKeys.length > 0) {\n      console.warn(\n        `WARNING: Unexpected config keys found: ${unexpectedConfigKeys.join(\n          \", \",\n        )}. Valid config keys are: ${CLIENT_OPTIONS_KEYS.join(\n          \", \",\n        )}. The unexpected keys will be ignored.`,\n      );\n    }\n\n    super({\n      apiKey: config.apiKey,\n      baseURL: config.baseURL ?? \"https://app.hamming.ai/api/rest\",\n    });\n\n    this.openaiApiKey = config.openaiApiKey;\n    this.anthropicApiKey = config.anthropicApiKey;\n    this.bedrock = config.bedrock;\n  }\n\n  experiments = new Experiments(this);\n  datasets = new Datasets(this);\n  tracing = new Tracing(this);\n  monitoring = new Monitoring(this);\n  prompts = new Prompts(this);\n  openai = new OpenAIClient(this);\n  anthropic = new AnthropicClient(this);\n  anthropicBedrock = new AnthropicBedrockClient(this);\n\n  _logger = new Logger(this);\n}\n"],"mappings":"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","names":["src_exports","__export","ExperimentStatus","FunctionType","Hamming","LabelColor","LogMessageType","MonitoringItemStatus","PromptTemplate","ScoreParserType","ScoreType","ScorerExecutionType","ScoringErrorPrefix","ScoringErrorValue","SessionEnvironment","TracingMode","__toCommonJS","FetchClient","defaults","finalDefaults","ArgumentError","value","input","init","retries","retryDelay","retryOn","resolve","reject","wrappedFetch","attempt","_input","response","retryOnResponse","retry","error","delay","message","fetchClient_default","TOO_MANY_REQUESTS","INTERNAL_SERVER_ERROR","UNAUTHORIZED","HttpClient","opts","fetchClient_default","baseURL","input","init","_a","url","requestInit","isDebug","numRetries","resp","attempt","error","response","status","ManualResetEvent","isSet","resolve","LOG_BATCH_SIZE","Logger","ManualResetEvent","client","message","batchSize","messages","logs","PromptTemplate","prompt","messages","message","match","values","pattern","DEFAULT_ANTHROPIC_MAX_TOKENS","convertAnthropicToolChoice","input","convertChatMessage","message","createMessageParams","content","systemMessage","messages","AnthropicClient","client","module","prompt","variables","content","PromptTemplate","params","createMessageParams","anthropic_client_default","AnthropicBedrockClient","client","_a","_b","_c","_d","module","prompt","variables","content","PromptTemplate","params","createMessageParams","anthropic_bedrock_client_default","Datasets","client","id","resp","data","error","opts","name","description","items","import_node_async_hooks","asyncRunContext","ScoreType","ExperimentStatus","TracingMode","MonitoringItemStatus","SessionEnvironment","LogMessageType","FunctionType","ScorerExecutionType","ScoreParserType","ScoringErrorValue","ScoringErrorPrefix","LabelColor","runWorkers","workItems","runFn","count","iterator","workerCount","workers","idx","index","workItem","MAX_SAMPLES","newRunContext","itemId","defaultScoreTypes","ExperimentItems","client","experiment","datasetItem","sampleId","item","startTs","itemContext","output","scores","failed","durationMs","Experiments","opts","run","datasetId","dataset","name","scoring","metadata","sampling","sampleCount","scoringHelper","ScoringHelper","experimentUrl","runFn","itemCtx","asyncRunContext","err","workerCount","runWorkers","status","datasetName","score","f","input","expected","promises","scorer","ScoringErrorPrefix","scoringFunc","getExecutionConfig","registrations","scoringFunction","idx","prompt","variableMappings","scoreParser","TracerBase","params","_a","_b","isString","item","hasStringResults","normalizeResult","result","results","keyOrTrace","value","event","updatedParams","Tracing","client","mode","experimentItemId","events","rootTrace","traces","trace","runCtx","asyncRunContext","itemId","INVALID_SESSION_ID","newRunContext","seqId","MonitoringItemTracing","TracerBase","client","event","trace","MonitoringItem","sessionId","input","output","metadata","error","errorMessage","Monitoring","opts","callback","item","response","asyncRunContext","ctx","_a","_b","parentSeqId","environment","data","import_streaming","OpenAIClient","client","module","prompt","variables","content","PromptTemplate","params","createChatCompletionParams","item","meta","completion","e","original","chunks","chunk","lastChunk","m","convertChatMessage","convertToolChoice","message","toolChoice","openai_client_default","Prompts","client","label","url","slug","version","CLIENT_OPTIONS_KEYS","Hamming","HttpClient","config","unexpectedConfigKeys","key","Experiments","Datasets","Tracing","Monitoring","Prompts","openai_client_default","anthropic_client_default","anthropic_bedrock_client_default","Logger"]}