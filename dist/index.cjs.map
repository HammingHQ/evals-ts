{"version":3,"sources":["../src/index.ts"],"names":["ExperimentStatus","ExperimentItems","client","__publicField","experiment","datasetItem","item","startTs","itemContext","output","durationMs","Experiments","opts","run","datasetId","dataset","name","scoring","DefaultScoreTypes","err","status","datasetName","ScoreType","Datasets","id","description","items","HttpClient","baseURL","input","init","Tracing","experimentItemId","events","rootTrace","traces","event","params","result","keyOrTrace","value","Hamming","config"],"mappings":"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","sourcesContent":["export enum ExperimentStatus {\n  CREATED = \"CREATED\",\n  RUNNING = \"RUNNING\",\n  SCORING = \"SCORING\",\n  SCORING_FAILED = \"SCORING_FAILED\",\n  FINISHED = \"FINISHED\",\n  FAILED = \"FAILED\",\n}\n\nexport interface ClientOptions {\n  apiKey: string;\n  baseURL: string;\n  verbose?: boolean;\n}\n\nexport interface Experiment {\n  id: number;\n  name: string;\n  description?: string | null;\n  datasetId: number;\n  datasetVersionId?: number;\n  status: ExperimentStatus;\n}\n\nexport interface ExperimentItemMetrics {\n  durationMs?: number;\n}\n\nexport interface ExperimentItem {\n  id: number;\n  experimentId: number;\n  datasetItemId: number;\n  output: OutputType;\n  metrics: ExperimentItemMetrics;\n}\n\nexport interface ExperimentItemContext {\n  item: ExperimentItem;\n  startTs: number;\n}\n\nexport type InputType = { query: string } & Record<string, any>;\nexport type OutputType = { response?: string } & Record<string, any>;\nexport type MetadataType = Record<string, any>;\n\nexport interface DatasetItemValue {\n  input: InputType;\n  output: OutputType;\n  metadata: MetadataType;\n}\n\ntype DatasetItem = DatasetItemValue & { id: number };\n\ninterface Dataset {\n  id: number;\n  name: string;\n  description?: string;\n  items: DatasetItem[];\n}\n\ninterface DatasetLite {\n  id: number;\n  name: string;\n  description?: string;\n}\n\nclass ExperimentItems {\n  private client: Hamming;\n\n  constructor(client: Hamming) {\n    this.client = client;\n  }\n\n  async start(\n    experiment: Experiment,\n    datasetItem: DatasetItem\n  ): Promise<ExperimentItemContext> {\n    const resp = await this.client.fetch(\n      `/experiments/${experiment.id}/items`,\n      {\n        method: \"POST\",\n        body: JSON.stringify({\n          datasetItemId: datasetItem.id,\n          output: {},\n          metrics: {},\n        }),\n      }\n    );\n    const data = await resp.json();\n    const item = data.item as ExperimentItem;\n\n    const startTs = Date.now();\n    return {\n      item,\n      startTs,\n    };\n  }\n\n  async end(itemContext: ExperimentItemContext, output: OutputType) {\n    const { item, startTs } = itemContext;\n    const durationMs = Date.now() - startTs;\n    await this.client.fetch(\n      `/experiments/${item.experimentId}/items/${item.id}`,\n      {\n        method: \"PATCH\",\n        body: JSON.stringify({\n          output,\n          metrics: {\n            durationMs,\n          },\n        }),\n      }\n    );\n    await this.client.tracing._flush(item.id);\n  }\n}\n\nclass Experiments {\n  private client: Hamming;\n  private items: ExperimentItems;\n\n  constructor(client: Hamming) {\n    this.client = client;\n    this.items = new ExperimentItems(this.client);\n  }\n\n  async run(opts: RunOptions, run: Runner) {\n    const { dataset: datasetId } = opts;\n    const dataset = await this.client.datasets.load(datasetId);\n\n    const {\n      name = this.generateName(dataset.name),\n      scoring = DefaultScoreTypes,\n    } = opts;\n\n    const experiment = await this.start(name, datasetId, scoring);\n    try {\n      for (const datasetItem of dataset.items) {\n        const itemContext = await this.items.start(experiment, datasetItem);\n        const output = await run(datasetItem.input);\n        await this.items.end(itemContext, output);\n      }\n    } catch (err) {\n      await this.end(experiment, ExperimentStatus.FAILED);\n      throw err;\n    } finally {\n      await this.end(experiment);\n    }\n  }\n\n  private async start(\n    name: string,\n    dataset: number,\n    scoring: ScoreType[]\n  ): Promise<Experiment> {\n    const status = ExperimentStatus.RUNNING;\n    const resp = await this.client.fetch(\"/experiments\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        name,\n        dataset,\n        status,\n        scoring,\n      }),\n    });\n    const data = await resp.json();\n    return data.experiment as Experiment;\n  }\n\n  private async end(\n    experiment: Experiment,\n    status: ExperimentStatus = ExperimentStatus.FINISHED\n  ) {\n    await this.client.fetch(`/experiments/${experiment.id}`, {\n      method: \"PATCH\",\n      body: JSON.stringify({\n        status,\n      }),\n    });\n  }\n\n  private generateName(datasetName: string): string {\n    const now = new Date();\n    return `Experiment for ${datasetName} - ${now.toLocaleString()}`;\n  }\n}\n\nexport type DatasetId = number;\n\ninterface RunOptions {\n  dataset: DatasetId;\n  name?: string;\n  scoring?: ScoreType[];\n}\n\nexport type Runner = (input: InputType) => Promise<OutputType>;\n\nexport enum ScoreType {\n  AccuracyAI = \"accuracy_ai\",\n  AccuracyHuman = \"accuracy_human\",\n  FactsCompare = \"facts_compare\",\n  ContextRecall = \"context_recall\",\n  ContextPrecision = \"context_precision\",\n  Hallucination = \"hallucination\",\n  StringDiff = \"string_diff\",\n}\n\nexport const DefaultScoreTypes = [ScoreType.StringDiff];\n\nclass Datasets {\n  private client: Hamming;\n\n  constructor(client: Hamming) {\n    this.client = client;\n  }\n\n  async load(id: DatasetId): Promise<Dataset> {\n    const resp = await this.client.fetch(`/datasets/${id}`);\n    const data = await resp.json();\n    return data.dataset as Dataset;\n  }\n\n  async list(): Promise<DatasetLite[]> {\n    const resp = await this.client.fetch(`/datasets`);\n    const data = await resp.json();\n    return data.datasets as DatasetLite[];\n  }\n\n  async create(opts: CreateDatasetOptions): Promise<Dataset> {\n    const { name, description, items } = opts;\n    const resp = await this.client.fetch(\"/datasets\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        name,\n        description,\n        items,\n      }),\n    });\n    const data = await resp.json();\n    return data.dataset as Dataset;\n  }\n}\n\nexport interface CreateDatasetOptions {\n  name: string;\n  description?: string;\n  items: DatasetItemValue[];\n}\n\nclass HttpClient {\n  apiKey: string;\n  baseURL: string;\n  verbose: boolean;\n\n  constructor(opts: ClientOptions) {\n    this.apiKey = opts.apiKey;\n    this.baseURL = this.sanitize_base_url(opts.baseURL);\n    this.verbose = opts.verbose ?? false;\n  }\n\n  private sanitize_base_url(baseURL: string): string {\n    baseURL = baseURL.trim();\n    if (baseURL.endsWith(\"/\")) {\n      return baseURL.slice(0, -1);\n    }\n    return baseURL;\n  }\n\n  fetch(input: string, init?: RequestInit | undefined): Promise<Response> {\n    return fetch(this.baseURL + input, {\n      ...init,\n      headers: {\n        ...init?.headers,\n        authorization: `Bearer ${this.apiKey}`,\n        \"content-type\": \"application/json\",\n      },\n    });\n  }\n}\n\ntype TraceEvent = Record<string, unknown>;\n\ninterface LLMEventParams {\n  input?: string;\n  output?: string;\n  metadata?: {\n    model?: string;\n  };\n}\n\ninterface Document {\n  pageContent: string;\n  metadata: Record<string, any>;\n}\n\ninterface VectorSearchEventParams {\n  query?: string;\n  results?: Document[] | string[];\n  metadata?: {\n    engine?: string;\n  };\n}\n\ninterface Trace {\n  id: number;\n  experimentItemId: number;\n  parentId?: number;\n  event: TraceEvent;\n}\n\nclass Tracing {\n  private client: Hamming;\n  private collected: TraceEvent[] = [];\n  private currentLocalTraceId: number = 0;\n\n  constructor(client: Hamming) {\n    this.client = client;\n  }\n\n  private nextTraceId(): number {\n    return this.currentLocalTraceId++;\n  }\n\n  async _flush(experimentItemId: number) {\n    const events = this.collected;\n    this.collected = [];\n\n    const rootTrace: Trace = {\n      id: this.nextTraceId(),\n      experimentItemId,\n      event: { kind: \"root\" },\n    };\n\n    const traces: Trace[] = [rootTrace];\n\n    for (const event of events) {\n      traces.push({\n        id: this.nextTraceId(),\n        experimentItemId,\n        parentId: rootTrace.id,\n        event,\n      });\n    }\n\n    await this.client.fetch(`/traces`, {\n      method: \"POST\",\n      body: JSON.stringify({\n        traces,\n      }),\n    });\n  }\n\n  LLMEvent(params: LLMEventParams): TraceEvent {\n    return {\n      kind: \"llm\",\n      ...params,\n    };\n  }\n\n  VectorSearchEvent(params: VectorSearchEventParams): TraceEvent {\n    //Our goal is to normalize normal string elements into the document structure\n    if (\n      Array.isArray(params.results) &&\n      params.results.every((item) => typeof item === \"string\")\n    ) {\n      params.results = params.results.map((result: any) => ({\n        pageContent: result,\n        metadata: {},\n      }));\n    }\n\n    return {\n      kind: \"vector\",\n      ...params,\n    };\n  }\n\n  log(key: string, value: unknown): void;\n  log(trace: TraceEvent): void;\n  log(keyOrTrace: string | TraceEvent, value?: unknown): void {\n    if (typeof keyOrTrace === \"string\") {\n      this.collected.push({ [keyOrTrace]: value });\n    } else {\n      this.collected.push(keyOrTrace);\n    }\n  }\n}\n\nexport class Hamming extends HttpClient {\n  constructor(config: ClientOptions) {\n    super({\n      apiKey: config.apiKey,\n      baseURL: config.baseURL,\n      verbose: config.verbose,\n    });\n  }\n\n  experiments = new Experiments(this);\n  datasets = new Datasets(this);\n  tracing = new Tracing(this);\n}\n"]}