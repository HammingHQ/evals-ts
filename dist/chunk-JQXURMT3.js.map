{"version":3,"sources":["../src/resources/monitoring.ts"],"sourcesContent":["import type {\n  Hamming,\n  MonitoringStartOpts,\n  RunContext,\n  TraceEvent,\n} from \"../index\";\n\nimport {\n  MonitoringItem as IMonitoringItem,\n  ITracing,\n  InputType,\n  MetadataType,\n  MonitoringItemStatus,\n  MonitoringSession,\n  MonitoringTrace,\n  OutputType,\n  TracingMode,\n  MonitoringTraceContext,\n} from \"../types\";\nimport { asyncRunContext } from \"../asyncStorage\";\nimport { TracerBase } from \"./tracing\";\n\nenum MonitoringState {\n  STARTED,\n  STOPPED,\n}\n\nconst INVALID_SESSION_ID = \"INVALID_SESSION\";\n\nfunction newRunContext(seqId: number): RunContext {\n  return {\n    tracing: {\n      monitoring: {\n        seqId,\n      },\n    },\n  };\n}\n\nclass MonitoringItemTracing extends TracerBase implements ITracing {\n  client: Hamming;\n  runCtx: RunContext;\n\n  constructor(client: Hamming, seqId: number) {\n    super();\n    this.client = client;\n    this.runCtx = newRunContext(seqId);\n  }\n\n  logEvent(event: TraceEvent) {\n    const trace = this.client.monitoring._getTraceContext(this.runCtx);\n    if (!trace) return;\n    this.client.tracing._logLiveTrace({\n      event,\n      ...trace,\n    });\n  }\n}\n\nclass MonitoringItem implements IMonitoringItem {\n  client: Hamming;\n  sessionId: string;\n  seqId: number;\n  input: InputType | undefined;\n  output: OutputType | undefined;\n  metadata: MetadataType | undefined;\n  metrics: Record<string, any>;\n  status: MonitoringItemStatus;\n  errorMessage: string | undefined;\n  startTs: number;\n\n  tracing: ITracing;\n\n  constructor(client: Hamming, sessionId: string, seqId: number) {\n    this.client = client;\n    this.sessionId = sessionId;\n    this.seqId = seqId;\n    this.metrics = {};\n    this.tracing = new MonitoringItemTracing(client, seqId);\n  }\n\n  setInput(input: InputType) {\n    this.input = input;\n  }\n\n  setOutput(output: OutputType) {\n    this.output = output;\n  }\n\n  setMetadata(metadata: MetadataType) {\n    this.metadata = metadata;\n  }\n\n  end(error: boolean = false, errorMessage?: string) {\n    this._end(error, errorMessage);\n  }\n\n  _start() {\n    this.startTs = Date.now();\n    this.status = MonitoringItemStatus.STARTED;\n  }\n\n  _end(error: boolean = false, errorMessage?: string) {\n    if (this._hasEnded()) return;\n\n    this.metrics.duration_ms = Date.now() - this.startTs;\n    this.status = error\n      ? MonitoringItemStatus.FAILED\n      : MonitoringItemStatus.COMPLETED;\n    this.errorMessage = errorMessage;\n    this.client.monitoring._endItem(this._toTrace());\n  }\n\n  _hasEnded() {\n    return [\n      MonitoringItemStatus.COMPLETED,\n      MonitoringItemStatus.FAILED,\n    ].includes(this.status);\n  }\n\n  _toTrace(): MonitoringTrace {\n    return {\n      session_id: this.sessionId,\n      seq_id: this.seqId,\n      parent_seq_id: undefined,\n      event: {\n        kind: \"root\",\n        input: this.input,\n        output: this.output,\n        metadata: this.metadata,\n        metrics: this.metrics,\n        status: this.status,\n        error_message: this.errorMessage,\n      },\n    };\n  }\n}\n\nexport class Monitoring {\n  client: Hamming;\n  private state: MonitoringState = MonitoringState.STOPPED;\n  private session: MonitoringSession | null;\n  private monitoringStartOpts: MonitoringStartOpts | undefined;\n\n  constructor(client: Hamming) {\n    this.client = client;\n  }\n\n  start(opts?: MonitoringStartOpts) {\n    // Delay creating session until the first async call of runItem\n    this.monitoringStartOpts = opts;\n    this.client._logger.start();\n    this.client.tracing._setMode(TracingMode.MONITORING);\n    this.state = MonitoringState.STARTED;\n    console.log(\"Monitoring started!\");\n  }\n\n  stop() {\n    this.session = null;\n    this.client.tracing._setMode(TracingMode.OFF);\n    this.client._logger.stop();\n    this.state = MonitoringState.STOPPED;\n    console.log(\"Monitoring stopped!\");\n  }\n\n  async runItem(\n    callback: (item: IMonitoringItem) => unknown | Promise<unknown>,\n  ): Promise<unknown> {\n    await this._createSessionIfNotExist();\n    const [sessionId, seqId] = this._nextSeqId();\n\n    const item = new MonitoringItem(this.client, sessionId, seqId);\n    item._start();\n\n    try {\n      const response = await asyncRunContext.run(\n        newRunContext(item.seqId),\n        async () => await callback(item),\n      );\n      if (!item.output) {\n        if (\n          response &&\n          response instanceof Object &&\n          !Array.isArray(response)\n        ) {\n          item.setOutput(response);\n        } else {\n          item.setOutput({ response });\n        }\n      }\n      item._end();\n\n      return response;\n    } catch (error) {\n      item._end(true, error.message);\n      throw error;\n    }\n  }\n\n  async startItem(): Promise<IMonitoringItem> {\n    await this._createSessionIfNotExist();\n    const [sessionId, seqId] = this._nextSeqId();\n\n    const item = new MonitoringItem(this.client, sessionId, seqId);\n    item._start();\n    return item;\n  }\n\n  _endItem(trace: MonitoringTrace) {\n    if (this.state === MonitoringState.STOPPED) {\n      return;\n    }\n    this.client.tracing._logLiveTrace(trace);\n  }\n\n  _getTraceContext(ctx?: RunContext): MonitoringTraceContext | null {\n    if (this.state === MonitoringState.STOPPED) {\n      return null;\n    }\n    if (!this.session) throw Error(\"Monitoring not started\");\n\n    const [sessionId, seqId] = this._nextSeqId();\n    const parentSeqId = ctx?.tracing?.monitoring?.seqId;\n\n    return {\n      session_id: sessionId,\n      seq_id: seqId,\n      parent_seq_id: parentSeqId,\n    };\n  }\n\n  private _nextSeqId(): [string, number] {\n    if (this.state === MonitoringState.STOPPED) {\n      return [INVALID_SESSION_ID, 0];\n    }\n    if (!this.session) {\n      throw Error(\"Monitoring not started\");\n    }\n    this.session.seqId += 1;\n    return [this.session.id, this.session.seqId];\n  }\n\n  private async _createSessionIfNotExist() {\n    if (this.state === MonitoringState.STOPPED) {\n      return;\n    }\n    if (this.session) return;\n    const environment =\n      this.monitoringStartOpts?.environment ?? process.env.NODE_ENV;\n    const resp = await this.client.fetch(\"/sessions\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        metadata: environment ? { environment } : {},\n      }),\n    });\n    const data = await resp.json();\n    this.session = {\n      id: data.id,\n      seqId: 0,\n    };\n  }\n}\n"],"mappings":"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","names":["INVALID_SESSION_ID","newRunContext","seqId","MonitoringItemTracing","TracerBase","client","__publicField","event","trace","MonitoringItem","sessionId","input","output","metadata","error","errorMessage","Monitoring","opts","callback","item","response","asyncRunContext","ctx","parentSeqId","environment","data"]}