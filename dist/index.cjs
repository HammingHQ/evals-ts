var gt=Object.create;var v=Object.defineProperty;var ht=Object.getOwnPropertyDescriptor;var dt=Object.getOwnPropertyNames;var ft=Object.getPrototypeOf,yt=Object.prototype.hasOwnProperty;var It=(n,t)=>{for(var e in t)v(n,e,{get:t[e],enumerable:!0})},J=(n,t,e,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of dt(t))!yt.call(n,i)&&i!==e&&v(n,i,{get:()=>t[i],enumerable:!(r=ht(t,i))||r.enumerable});return n};var X=(n,t,e)=>(e=n!=null?gt(ft(n)):{},J(t||!n||!n.__esModule?v(e,"default",{value:n,enumerable:!0}):e,n)),xt=n=>J(v({},"__esModule",{value:!0}),n);var Dt={};It(Dt,{ExperimentStatus:()=>k,FunctionType:()=>et,Hamming:()=>j,LabelColor:()=>it,LogMessageType:()=>H,MonitoringItemStatus:()=>F,PromptTemplate:()=>g,ScoreParserType:()=>rt,ScoreType:()=>q,ScorerExecutionType:()=>$,ScoringErrorPrefix:()=>G,ScoringErrorValue:()=>nt,SessionEnvironment:()=>tt,TracingMode:()=>T});module.exports=xt(Dt);var A=class{retries;retryDelay;retryOn;constructor(t){let r={...{retries:3,retryDelay:1e3,retryOn:[]},...t};this.validateDefaults(r),this.retries=r.retries,this.retryDelay=r.retryDelay,this.retryOn=r.retryOn}validateDefaults(t){if(t.retries!==void 0&&!this.isPositiveInteger(t.retries))throw new x("retries must be a positive integer");if(t.retryDelay!==void 0&&!this.isPositiveInteger(t.retryDelay)&&typeof t.retryDelay!="function")throw new x("retryDelay must be a positive integer or a function returning a positive integer");if(t.retryOn!==void 0&&!Array.isArray(t.retryOn)&&typeof t.retryOn!="function")throw new x("retryOn property expects an array or function")}isPositiveInteger(t){return Number.isInteger(t)&&t>=0}fetchRetry(t,e){let r=this.retries,i=this.retryDelay,s=this.retryOn;return e&&(e.retries!==void 0&&this.isPositiveInteger(e.retries)&&(r=e.retries),e.retryDelay!==void 0&&(this.isPositiveInteger(e.retryDelay)||typeof e.retryDelay=="function")&&(i=e.retryDelay),e.retryOn&&(Array.isArray(e.retryOn)||typeof e.retryOn=="function")&&(s=e.retryOn)),new Promise((o,p)=>{let c=m=>{let a=t instanceof Request?t.clone():t;fetch(a,e).then(u=>{Array.isArray(s)&&!s.includes(u.status)?o(u):typeof s=="function"?Promise.resolve(s(m,null,u)).then(h=>{h?l(m,null,u):o(u)}).catch(p):m<r?l(m,null,u):o(u)}).catch(u=>{typeof s=="function"?Promise.resolve(s(m,u,null)).then(h=>{h?l(m,u,null):p(u)}).catch(p):m<r?l(m,u,null):p(u)})},l=(m,a,u)=>{let h=typeof i=="function"?i(m,a,u,t):i;setTimeout(()=>{c(++m)},h)};c(0)})}},x=class extends Error{constructor(t){super(t),this.name="ArgumentError"}},B=A;var Tt=429,Ct=500,wt=401,P=class{apiKey;baseURL;fetchClient;debug=!1;retries=3;constructor(t){this.apiKey=t.apiKey,this.baseURL=this.sanitizeBaseUrl(t.baseURL),this.fetchClient=new B,this.debug=process.env.NODE_ENV==="development"}sanitizeBaseUrl(t){return t.trim().replace(/\/$/,"")}async fetch(t,e){var c;let r=this.baseURL+t,i={...e,headers:{...e==null?void 0:e.headers,"Content-Type":((c=e==null?void 0:e.headers)==null?void 0:c["Content-Type"])??"application/json",authorization:`Bearer ${this.apiKey}`}},s=this.debug;s&&console.debug(`
Fetching URL: ${r}
Method: ${i.method||"GET"}${i.body?`
Body: ${i.body}`:""}
Headers: ${JSON.stringify(i.headers,null,2)}`);let o=this.retries,p=await this.fetchClient.fetchRetry(r,{...i,retryOn:function(l,m,a){if(l>=o)return!1;let u=a==null?void 0:a.status;return m instanceof TypeError||u===Tt||u!==void 0&&u>=Ct},retryDelay:function(l,m,a,u){return console.warn(`Fetch attempt #${l}: input=${u}, error=${m==null?void 0:m.message}, response status=${a==null?void 0:a.status}, response status text=${a==null?void 0:a.statusText}`),Math.pow(2,l)*1e3}});if(p.status===wt)throw new Error(`Unauthorized. Please check that your HAMMING_API_KEY is correct by visiting: ${this.baseURL}/settings`);return s&&console.debug(`Response for ${r}: ${p.status} ${p.statusText}
`),p}};var E=class{isSet;waiters;constructor(t=!1){this.isSet=t,this.waiters=[],t&&this.resolveWaiters()}set(){this.isSet=!0,this.resolveWaiters()}reset(){this.isSet=!1}wait(){return this.isSet?Promise.resolve():new Promise(t=>{this.waiters.push(t)})}resolveWaiters(){this.waiters.forEach(t=>t()),this.waiters=[]}};var St=512,R=class{client;queue=[];stopped=!1;queueHasMessages=new E;constructor(t){this.client=t}log(t){this.queue.push(t),this.queueHasMessages.set()}async start(){for(console.log("Starting logger thread..");!this.stopped;)await this.queueHasMessages.wait(),await this._processQueue();await this._processQueue(),console.log("Logger thread exited!")}stop(){console.log("Waiting for logger thread to exit.."),this.stopped=!0}_drainQueue(){let t=Math.min(this.queue.length,St);return this.queue.splice(0,t)}async _processQueue(){let t=this._drainQueue();await this._publish(t),this.queue.length===0&&this.queueHasMessages.reset()}async _publish(t){if(t.length!==0){process.env.NODE_ENV==="development"&&console.log(`Publishing ${t.length} message(s)..`);try{await this.client.fetch("/logs",{method:"POST",body:JSON.stringify({logs:t})}),process.env.NODE_ENV==="development"&&console.log(`Published ${t.length} messages!`)}catch(e){console.error(`Failed to publish messages: ${e}`)}}}};var g=class{prompt;vars;constructor(t){this.prompt=t,this.vars=this.extractVariables(t.chatMessages??[])}extractVariables(t){return(t.map(i=>i.content).join(`

`).match(/\{\{([^}]+)\}\}/g)??[]).map(i=>i.replace(/\{\{([^}]+)\}\}/g,"$1"))}compile(t){return{...this.prompt,chatMessages:this.prompt.chatMessages.map(e=>({...e,content:e.content.replace(/\{\{([^}]+)\}\}/g,(r,i)=>t[i]||r)}))}}};var vt=4096,L=class{constructor(t){this.client=t}anthropic;async load(){if(this.anthropic)return this.anthropic;if(!this.client.anthropicApiKey)throw new Error("Anthropic API key is not set");let t=await import("@anthropic-ai/sdk");return this.anthropic=new t.Anthropic({apiKey:this.client.anthropicApiKey}),this.anthropic}async createMessage(t,e){if(!t.content)throw new Error("Prompt content is not set");let i=new g(t.content).compile(e||{}),s=await this.load(),o=Q(i);return s.messages.create({...o,stream:!1})}async createMessageStream(t,e){if(!t.content)throw new Error("Prompt content is not set");let i=new g(t.content).compile(e||{}),s=await this.load(),o=Q(i);return s.messages.create({...o,stream:!0})}};function Q(n){let t=n.chatMessages.find(r=>r.role==="system"),e=n.chatMessages.filter(r=>r.role!=="system");return{model:n.languageModel,system:t==null?void 0:t.content,messages:e.map(Pt),max_tokens:n.promptSettings.maxTokens??vt,top_p:n.promptSettings.topP,temperature:n.promptSettings.temperature,tools:n.tools?JSON.parse(n.tools):void 0,tool_choice:n.promptSettings.toolChoice&&n.tools?Et(n.promptSettings.toolChoice):void 0}}function Pt(n){switch(n.role){case"user":return{role:"user",content:n.content};case"assistant":return{role:"assistant",content:n.content};default:throw new Error(`Unsupported role: ${n.role}`)}}function Et(n){switch(n.choice){case"auto":return{type:"auto"};case"any":return{type:"any"};case"tool":return{type:"tool",name:n.functionName??""};default:throw new Error("Invalid tool choice type")}}var Y=L;var O=class{client;constructor(t){this.client=t}async load(t){let e=await this.client.fetch(`/datasets/${t}`,{method:"GET"}),r;try{r=await e.json()}catch(i){throw new Error(`Failed to parse dataset response as JSON for dataset ID: ${t}: ${i}`)}return r.dataset}async list(){return(await(await this.client.fetch("/datasets")).json()).datasets}async create(t){let{name:e,description:r,items:i}=t;return(await(await this.client.fetch("/datasets",{method:"POST",body:JSON.stringify({name:e,description:r,items:i})})).json()).dataset}};var Z=require("async_hooks"),f=new Z.AsyncLocalStorage;var q=(c=>(c.AccuracyAI="accuracy_ai",c.FactsCompare="facts_compare",c.ContextRecall="context_recall",c.ContextPrecision="context_precision",c.Hallucination="hallucination",c.StringDiff="string_diff",c.Refusal="refusal",c.SqlAst="sql_ast",c))(q||{}),k=(o=>(o.CREATED="CREATED",o.RUNNING="RUNNING",o.SCORING="SCORING",o.SCORING_FAILED="SCORING_FAILED",o.FINISHED="FINISHED",o.FAILED="FAILED",o))(k||{}),T=(r=>(r.OFF="off",r.MONITORING="monitoring",r.EXPERIMENT="experiment",r))(T||{}),F=(r=>(r.STARTED="STARTED",r.COMPLETED="COMPLETED",r.FAILED="FAILED",r))(F||{}),tt=(r=>(r.DEVELOPMENT="development",r.STAGING="staging",r.PRODUCTION="production",r))(tt||{}),H=(t=>(t[t.MONITORING=1]="MONITORING",t))(H||{}),et=(e=>(e.Numeric="numeric",e.Classification="classification",e))(et||{}),$=(e=>(e.Local="local",e.Remote="remote",e))($||{}),rt=(e=>(e.XML="xml",e.JSON="json",e))(rt||{}),nt=-1,G="<!--hamming_scoring_error-->",it=(a=>(a.Gray="gray",a.LightGreen="light-green",a.LightBlue="light-blue",a.Amber="amber",a.Purple="purple",a.Pink="pink",a.Green="green",a.PastelGreen="pastel-green",a.Yellow="yellow",a.Blue="blue",a.Red="red",a))(it||{});async function st(n,t,e=100){let r=n.entries(),i=Math.min(e,n.length,100),s=Array(i).fill(r).map(async(o,p)=>{for(let[c,l]of o)process.env.NODE_ENV==="development"&&console.log(`Worker ${p} is processing task ${c}`),await t(l),process.env.NODE_ENV==="development"&&console.log(`Worker ${p} has finished task ${c}`)});await Promise.all(s)}var ot=10;function at(n){return{tracing:{experiment:{itemId:n}}}}var Rt=["string_diff"],K=class{client;constructor(t){this.client=t}async start(t,e,r){let o=(await(await this.client.fetch(`/experiments/${t.id}/items`,{method:"POST",body:JSON.stringify({datasetItemId:e.id,output:{},metrics:{},sampleId:r})})).json()).item,p=Date.now();return{item:o,startTs:p}}async end(t,e,r={}){let{item:i,startTs:s}=t,o=Date.now()-s;await this.client.tracing._flush(i.id),await this.client.fetch(`/experiments/${i.experimentId}/items/${i.id}`,{method:"PATCH",body:JSON.stringify({output:e,scores:r,metrics:{durationMs:o}})})}},M=class{client;items;constructor(t){this.client=t,this.items=new K(this.client)}async run(t,e){let{dataset:r}=t,i=await this.client.datasets.load(r);this.client.tracing._setMode("experiment");let{name:s=this.generateName(i.name),scoring:o=Rt,metadata:p={},sampling:c}=t,l=c??1;if(l>ot)throw new Error(`The maximum number of samples is ${ot}.`);let m=new U(this.client,o);await m.initialize();let a=await this.start(s,r,m.getConfig(),p,c),h=`${new URL(this.client.baseURL).origin}/experiments/${a.id}`;try{for(let y=0;y<l;y++)if(t.parallel){let I=async d=>{let S=await this.items.start(a,d,y),z=await f.run(at(S.item.id),async()=>e(d.input)),lt=await m.score(d.input,d.output,z);await this.items.end(S,z,lt)},w=typeof t.parallel=="number"?t.parallel:void 0;await st(i.items,I,w)}else for(let I of i.items){let w=await this.items.start(a,I,y),d=await f.run(at(w.item.id),async()=>await e(I.input)),S=await m.score(I.input,I.output,d);await this.items.end(w,d,S)}}catch(y){throw await this.end(a,"FAILED"),y}finally{await this.end(a),console.log("See experiment results at:",h)}return{experimentUrl:h}}async start(t,e,r,i,s){let o="RUNNING";return(await(await this.client.fetch("/experiments",{method:"POST",body:JSON.stringify({name:t,dataset:e,status:o,scoring:r,metadata:i,sampling:s})})).json()).experiment}async end(t,e="FINISHED"){await this.client.fetch(`/experiments/${t.id}`,{method:"PATCH",body:JSON.stringify({status:e})})}generateName(t){return`Experiment for ${t} - ${new Date().toLocaleString()}`}},U=class{client;standardScoring;customScoring;registeredFunctions=[];initialized=!1;constructor(t,e){this.client=t,this.standardScoring=e.filter(r=>typeof r=="string"),this.customScoring=e.filter(r=>typeof r!="string")}async initialize(){await this.registerScoringFunctions(),this.initialized=!0}getConfig(){if(!this.initialized)throw new Error("ScoringHelper is not initialized");return[...this.standardScoring,...this.registeredFunctions.map(t=>t.registration)]}async score(t,e,r){if(!this.initialized)throw new Error("ScoringHelper is not initialized");let i={},s=this.registeredFunctions.filter(o=>o.scorer.type==="local").map(async o=>{let p=o.scorer;try{i[o.registration.key_name]=await p.scoreFn({input:t,output:r,expected:e})}catch(c){console.error(`Failed to locally run score ${o.name.toLowerCase()}.`,"Note: This error will be displayed in the dashboard. All other scoring will be preserved and displayed accordingly.","Error received:",c),i[o.registration.key_name]={value:-1,reason:`${G}${c.message}`}}});return await Promise.allSettled(s),i}async registerScoringFunctions(){let t=this.customScoring.map(s=>({name:s.name,version:s.version,score_config:s.scoreConfig,execution_config:Ot(s)})),i=(await(await this.client.fetch("/scoring/register-functions",{method:"POST",body:JSON.stringify({scoring:t})})).json()).scoring??[];this.registeredFunctions=this.customScoring.map((s,o)=>({...s,registration:i[o]}))}};function Ot(n){if(n.scorer.type==="remote"){let{prompt:t,variableMappings:e,scoreParser:r}=n.scorer;return{prompt:t,variableMappings:e,scoreParser:r}}return{}}var C=class{_generationEvent(t){return{kind:"llm",...t}}_retrievalEvent(t){var o,p;let e=c=>typeof c=="string",r=(o=t.results)==null?void 0:o.every(e),i=c=>typeof c=="string"?{pageContent:c,metadata:{}}:c,s=r?(p=t.results)==null?void 0:p.map(i):t.results;return{kind:"vector",...t,results:s}}log(t,e){let r=typeof t=="string"?{[t]:e}:t;this.logEvent(r)}logGeneration(t){var r,i;let e={...t,metadata:{...t.metadata,error:((r=t.metadata)==null?void 0:r.error)||!!((i=t.metadata)!=null&&i.error_message)}};this.log(this._generationEvent(e))}logRetrieval(t){this.log(this._retrievalEvent(t))}},b=class extends C{client;collected={};currentLocalTraceId=0;mode="off";constructor(t){super(),this.client=t}_setMode(t){this.mode=t}nextTraceId(){return this.currentLocalTraceId++}async _flush(t){if(this.mode!=="experiment"){console.warn("Tracing mode must be set to <experiment>!");return}let e=this.collected[t]??[];delete this.collected[t];let r={id:this.nextTraceId(),experimentItemId:t,event:{kind:"root"}},i=[r];for(let s of e)i.push({id:this.nextTraceId(),experimentItemId:t,parentId:r.id,event:s});await this.client.fetch("/traces",{method:"POST",body:JSON.stringify({traces:i})})}_logLiveTrace(t){if(this.mode!=="monitoring"){console.warn("Tracing mode must be set to <monitoring>!");return}this.client._logger.log({type:1,payload:t})}logEvent(t){var r,i;let e=f.getStore();if(this.mode==="experiment"){let s=(i=(r=e==null?void 0:e.tracing)==null?void 0:r.experiment)==null?void 0:i.itemId;if(!s){console.error("Unable to log trace event without experiment item ID.");return}this.collected[s]||(this.collected[s]=[]),this.collected[s].push(t)}else if(this.mode==="monitoring"){let s=this.client.monitoring._getTraceContext(e);if(!s)return;this._logLiveTrace({event:t,...s})}else console.warn("Attempt to send a log trace, but tracing mode is off!")}};var Mt="INVALID_SESSION";function ct(n){return{tracing:{monitoring:{seqId:n}}}}var W=class extends C{client;runCtx;constructor(t,e){super(),this.client=t,this.runCtx=ct(e)}logEvent(t){let e=this.client.monitoring._getTraceContext(this.runCtx);e&&this.client.tracing._logLiveTrace({event:t,...e})}},_=class{client;sessionId;seqId;input;output;metadata;metrics;status;errorMessage;startTs;tracing;constructor(t,e,r){this.client=t,this.sessionId=e,this.seqId=r,this.metrics={},this.tracing=new W(t,r)}setInput(t){this.input=t}setOutput(t){this.output=t}setMetadata(t){this.metadata=t}end(t=!1,e){this._end(t,e)}_start(){this.startTs=Date.now(),this.status="STARTED"}_end(t=!1,e){this._hasEnded()||(this.metrics.duration_ms=Date.now()-this.startTs,this.status=t?"FAILED":"COMPLETED",this.errorMessage=e,this.client.monitoring._endItem(this._toTrace()))}_hasEnded(){return["COMPLETED","FAILED"].includes(this.status)}_toTrace(){return{session_id:this.sessionId,seq_id:this.seqId,parent_seq_id:void 0,event:{kind:"root",input:this.input,output:this.output,metadata:this.metadata,metrics:this.metrics,status:this.status,error_message:this.errorMessage}}}},D=class{client;state=1;session;monitoringStartOpts;constructor(t){this.client=t}start(t){this.monitoringStartOpts=t,this.client._logger.start(),this.client.tracing._setMode("monitoring"),this.state=0,console.log("Monitoring started!")}stop(){this.session=null,this.client.tracing._setMode("off"),this.client._logger.stop(),this.state=1,console.log("Monitoring stopped!")}async runItem(t){await this._createSessionIfNotExist();let[e,r]=this._nextSeqId(),i=new _(this.client,e,r);i._start();try{let s=await f.run(ct(i.seqId),async()=>await t(i));return i.output||(s&&s instanceof Object&&!Array.isArray(s)?i.setOutput(s):i.setOutput({response:s})),i._end(),s}catch(s){throw i._end(!0,s.message),s}}async startItem(){await this._createSessionIfNotExist();let[t,e]=this._nextSeqId(),r=new _(this.client,t,e);return r._start(),r}_endItem(t){this.state!==1&&this.client.tracing._logLiveTrace(t)}_getTraceContext(t){var s,o;if(this.state===1)return null;if(!this.session)throw Error("Monitoring not started");let[e,r]=this._nextSeqId(),i=(o=(s=t==null?void 0:t.tracing)==null?void 0:s.monitoring)==null?void 0:o.seqId;return{session_id:e,seq_id:r,parent_seq_id:i}}_nextSeqId(){if(this.state===1)return[Mt,0];if(!this.session)throw Error("Monitoring not started");return this.session.seqId+=1,[this.session.id,this.session.seqId]}async _createSessionIfNotExist(){var i;if(this.state===1||this.session)return;let t=((i=this.monitoringStartOpts)==null?void 0:i.environment)??process.env.NODE_ENV,r=await(await this.client.fetch("/sessions",{method:"POST",body:JSON.stringify({metadata:t?{environment:t}:{}})})).json();this.session={id:r.id,seqId:0}}};var V=class{constructor(t){this.client=t}openai;async load(){if(this.openai)return this.openai;if(!this.client.openaiApiKey)throw new Error("OpenAI API key not set. Initialize the Hamming client with an OpenAI API key.");let t=await import("openai");return this.openai=new t.OpenAI({apiKey:this.client.openaiApiKey}),this.openai}async createChatCompletion(t,e){if(!t.content)throw new Error("Prompt content not set");let i=new g(t.content).compile(e||{}),s=await this.load(),o=pt(i);return await s.chat.completions.create({...o,stream:!1})}async createChatCompletionStream(t,e){if(!t.content)throw new Error("Prompt content not set");let i=new g(t.content).compile(e||{}),s=await this.load(),o=pt(i);return await s.chat.completions.create({...o,stream:!0})}};function pt(n){return{model:n.languageModel,messages:n.chatMessages.map(t=>bt(t)),temperature:n.promptSettings.temperature,max_tokens:n.promptSettings.maxTokens,top_p:n.promptSettings.topP,frequency_penalty:n.promptSettings.frequencyPenalty,presence_penalty:n.promptSettings.presencePenalty,tool_choice:n.promptSettings.toolChoice&&n.tools?_t(n.promptSettings.toolChoice):void 0,tools:n.tools?JSON.parse(n.tools):void 0}}function bt(n){switch(n.role){case"system":return{role:"system",content:n.content};case"user":return{role:"user",content:n.content};case"assistant":return{role:"assistant",content:n.content};default:throw new Error(`Unsupported message role: ${n.role}`)}}function _t(n){switch(n.choice){case"none":return"none";case"auto":return"auto";case"function":return{type:"function",function:{name:n.functionName}};default:throw new Error(`Unsupported tool choice: ${n.choice}`)}}var mt=V;var N=class{constructor(t){this.client=t}async list(t){let e="/prompts";return t&&(e+=`?label=${t}`),(await(await this.client.fetch(e)).json()).prompts}async get(t,e,r){let i=`/prompts/${t}`;return e&&(i+=`?label=${e}`),r&&(i+=`&version=${r}`),(await(await this.client.fetch(i)).json()).prompt}};var ut=["apiKey","baseURL","openaiApiKey","anthropicApiKey"],j=class extends P{openaiApiKey;anthropicApiKey;constructor(t){let e=Object.keys(t).filter(r=>!ut.includes(r));e.length>0&&console.warn(`WARNING: Unexpected config keys found: ${e.join(", ")}. Valid config keys are: ${ut.join(", ")}. The unexpected keys will be ignored.`),super({apiKey:t.apiKey,baseURL:t.baseURL??"https://app.hamming.ai/api/rest"}),this.openaiApiKey=t.openaiApiKey,this.anthropicApiKey=t.anthropicApiKey}experiments=new M(this);datasets=new O(this);tracing=new b(this);monitoring=new D(this);prompts=new N(this);openai=new mt(this);anthropic=new Y(this);_logger=new R(this)};0&&(module.exports={ExperimentStatus,FunctionType,Hamming,LabelColor,LogMessageType,MonitoringItemStatus,PromptTemplate,ScoreParserType,ScoreType,ScorerExecutionType,ScoringErrorPrefix,ScoringErrorValue,SessionEnvironment,TracingMode});
//# sourceMappingURL=index.cjs.map