var St=Object.create;var R=Object.defineProperty;var Rt=Object.getOwnPropertyDescriptor;var Pt=Object.getOwnPropertyNames;var Mt=Object.getPrototypeOf,Ot=Object.prototype.hasOwnProperty;var _t=(s,t)=>{for(var e in t)R(s,e,{get:t[e],enumerable:!0})},rt=(s,t,e,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of Pt(t))!Ot.call(s,r)&&r!==e&&R(s,r,{get:()=>t[r],enumerable:!(n=Rt(t,r))||n.enumerable});return s};var q=(s,t,e)=>(e=s!=null?St(Mt(s)):{},rt(t||!s||!s.__esModule?R(e,"default",{value:s,enumerable:!0}):e,s)),bt=s=>rt(R({},"__esModule",{value:!0}),s);var Vt={};_t(Vt,{CallProvider:()=>z,EventKind:()=>b,ExperimentStatus:()=>U,FunctionType:()=>pt,Hamming:()=>et,LabelColor:()=>ut,LogMessageType:()=>W,MonitoringItemStatus:()=>V,MonitoringItemType:()=>K,PromptTemplate:()=>d,RetellCallEventType:()=>B,ScoreParserType:()=>mt,ScoreType:()=>G,ScorerExecutionType:()=>j,ScoringErrorPrefix:()=>J,ScoringErrorValue:()=>lt,SessionEnvironment:()=>ct,TracingMode:()=>T,VapiCallEventType:()=>X});module.exports=bt(Vt);var $=class{retries;retryDelay;retryOn;constructor(t){let n={...{retries:3,retryDelay:1e3,retryOn:[]},...t};this.validateDefaults(n),this.retries=n.retries,this.retryDelay=n.retryDelay,this.retryOn=n.retryOn}validateDefaults(t){if(t.retries!==void 0&&!this.isPositiveInteger(t.retries))throw new x("retries must be a positive integer");if(t.retryDelay!==void 0&&!this.isPositiveInteger(t.retryDelay)&&typeof t.retryDelay!="function")throw new x("retryDelay must be a positive integer or a function returning a positive integer");if(t.retryOn!==void 0&&!Array.isArray(t.retryOn)&&typeof t.retryOn!="function")throw new x("retryOn property expects an array or function")}isPositiveInteger(t){return Number.isInteger(t)&&t>=0}fetchRetry(t,e){let n=this.retries,r=this.retryDelay,i=this.retryOn;return e&&(e.retries!==void 0&&this.isPositiveInteger(e.retries)&&(n=e.retries),e.retryDelay!==void 0&&(this.isPositiveInteger(e.retryDelay)||typeof e.retryDelay=="function")&&(r=e.retryDelay),e.retryOn&&(Array.isArray(e.retryOn)||typeof e.retryOn=="function")&&(i=e.retryOn)),new Promise((o,p)=>{let a=m=>{let c=t instanceof Request?t.clone():t;fetch(c,e).then(l=>{Array.isArray(i)&&!i.includes(l.status)?o(l):typeof i=="function"?Promise.resolve(i(m,null,l)).then(h=>{h?u(m,null,l):o(l)}).catch(p):m<n?u(m,null,l):o(l)}).catch(l=>{typeof i=="function"?Promise.resolve(i(m,l,null)).then(h=>{h?u(m,l,null):p(l)}).catch(p):m<n?u(m,l,null):p(l)})},u=(m,c,l)=>{let h=typeof r=="function"?r(m,c,l,t):r;setTimeout(()=>{a(++m)},h)};a(0)})}},x=class extends Error{constructor(t){super(t),this.name="ArgumentError"}},st=$;var Dt=429,kt=500,At=401,P=class{apiKey;baseURL;fetchClient;debug=!1;retries=3;constructor(t){this.apiKey=t.apiKey,this.baseURL=this.sanitizeBaseUrl(t.baseURL),this.fetchClient=new st,this.debug=process.env.NODE_ENV==="development"}sanitizeBaseUrl(t){return t.trim().replace(/\/$/,"")}async fetch(t,e){var a;let n=this.baseURL+t,r={...e,headers:{...e==null?void 0:e.headers,"Content-Type":((a=e==null?void 0:e.headers)==null?void 0:a["Content-Type"])??"application/json",authorization:`Bearer ${this.apiKey}`}},i=this.debug;i&&console.debug(`
Fetching URL: ${n}
Method: ${r.method||"GET"}${r.body?`
Body: ${r.body}`:""}
Headers: ${JSON.stringify(r.headers,null,2)}`);let o=this.retries,p=await this.fetchClient.fetchRetry(n,{...r,retryOn:function(u,m,c){if(u>=o)return!1;let l=c==null?void 0:c.status;return m instanceof TypeError||l===Dt||l!==void 0&&l>=kt},retryDelay:function(u,m,c,l){return console.warn(`Fetch attempt #${u}: input=${l}, error=${m==null?void 0:m.message}, response status=${c==null?void 0:c.status}, response status text=${c==null?void 0:c.statusText}`),Math.pow(2,u)*1e3}});if(p.status===At)throw new Error(`Unauthorized. Please check that your HAMMING_API_KEY is correct by visiting: ${this.baseURL}/settings`);return i&&console.debug(`Response for ${n}: ${p.status} ${p.statusText}
`),p}};var M=class{isSet;waiters;constructor(t=!1){this.isSet=t,this.waiters=[],t&&this.resolveWaiters()}set(){this.isSet=!0,this.resolveWaiters()}reset(){this.isSet=!1}wait(){return this.isSet?Promise.resolve():new Promise(t=>{this.waiters.push(t)})}resolveWaiters(){this.waiters.forEach(t=>t()),this.waiters=[]}};var Nt=512,O=class{client;queue=[];stopped=!1;queueHasMessages=new M;constructor(t){this.client=t}log(t){this.queue.push(t),this.queueHasMessages.set()}async start(){for(console.log("Starting logger thread..");!this.stopped;)await this.queueHasMessages.wait(),await this._processQueue();await this._processQueue(),console.log("Logger thread exited!")}stop(){console.log("Waiting for logger thread to exit.."),this.stopped=!0}_drainQueue(){let t=Math.min(this.queue.length,Nt);return this.queue.splice(0,t)}async _processQueue(){let t=this._drainQueue();await this._publish(t),this.queue.length===0&&this.queueHasMessages.reset()}async _publish(t){if(t.length!==0){process.env.NODE_ENV==="development"&&console.log(`Publishing ${t.length} message(s)..`);try{await this.client.fetch("/logs",{method:"POST",body:JSON.stringify({logs:t})}),process.env.NODE_ENV==="development"&&console.log(`Published ${t.length} messages!`)}catch(e){console.error(`Failed to publish messages: ${e}`)}}}};var d=class{prompt;vars;constructor(t){this.prompt=t,this.vars=this.extractVariables(t.chatMessages??[])}extractVariables(t){return(t.map(r=>r.content).join(`

`).match(/\{\{([^}]+)\}\}/g)??[]).map(r=>r.replace(/\{\{([^}]+)\}\}/g,"$1"))}compile(t){return{...this.prompt,chatMessages:this.prompt.chatMessages.map(e=>({...e,content:e.content.replace(/\{\{([^}]+)\}\}/g,(n,r)=>t[r]||n)}))}}};var Lt=4096;function qt(s){switch(s.choice){case"auto":return{type:"auto"};case"any":return{type:"any"};case"tool":return{type:"tool",name:s.functionName??""};default:throw new Error("Invalid tool choice type")}}function $t(s){switch(s.role){case"user":return{role:"user",content:s.content};case"assistant":return{role:"assistant",content:s.content};default:throw new Error(`Unsupported role: ${s.role}`)}}function E(s){let t=s.chatMessages.find(n=>n.role==="system"),e=s.chatMessages.filter(n=>n.role!=="system");return{model:s.languageModel,system:t==null?void 0:t.content,messages:e.map($t),max_tokens:s.promptSettings.maxTokens??Lt,top_p:s.promptSettings.topP,temperature:s.promptSettings.temperature,tools:s.tools?JSON.parse(s.tools):void 0,tool_choice:s.promptSettings.toolChoice&&s.tools?qt(s.promptSettings.toolChoice):void 0}}var H=class{constructor(t){this.client=t}anthropic;async load(){if(this.anthropic)return this.anthropic;if(!this.client.anthropicApiKey)throw new Error("Anthropic API key is not set");let t=await import("@anthropic-ai/sdk");return this.anthropic=new t.Anthropic({apiKey:this.client.anthropicApiKey}),this.anthropic}async createMessage(t,e){if(!t.content)throw new Error("Prompt content is not set");let r=new d(t.content).compile(e||{}),i=await this.load(),o=E(r);return i.messages.create({...o,stream:!1})}async createMessageStream(t,e){if(!t.content)throw new Error("Prompt content is not set");let r=new d(t.content).compile(e||{}),i=await this.load(),o=E(r);return i.messages.create({...o,stream:!0})}},it=H;var F=class{constructor(t){this.client=t}anthropic;async load(){var e,n,r,i;if(this.anthropic)return this.anthropic;this.client.bedrock||console.log("Anthropic Bedrock config is not set. Using environment credentials.");let t=await import("@anthropic-ai/bedrock-sdk");return this.anthropic=new t.AnthropicBedrock({awsSecretKey:(e=this.client.bedrock)==null?void 0:e.awsSecretKey,awsAccessKey:(n=this.client.bedrock)==null?void 0:n.awsAccessKey,awsRegion:(r=this.client.bedrock)==null?void 0:r.awsRegion,awsSessionToken:(i=this.client.bedrock)==null?void 0:i.awsSessionToken}),this.anthropic}async createMessage(t,e){if(!t.content)throw new Error("Prompt content is not set");let r=new d(t.content).compile(e||{}),i=await this.load(),o=E(r);return i.messages.create({...o,stream:!1})}async createMessageStream(t,e){if(!t.content)throw new Error("Prompt content is not set");let r=new d(t.content).compile(e||{}),i=await this.load(),o=E(r);return i.messages.create({...o,stream:!0})}},ot=F;var _=class{client;constructor(t){this.client=t}async load(t){let e=await this.client.fetch(`/datasets/${t}`,{method:"GET"}),n;try{n=await e.json()}catch(r){throw new Error(`Failed to parse dataset response as JSON for dataset ID: ${t}: ${r}`)}return n.dataset}async list(){return(await(await this.client.fetch("/datasets")).json()).datasets}async create(t){let{name:e,description:n,items:r}=t;return(await(await this.client.fetch("/datasets",{method:"POST",body:JSON.stringify({name:e,description:n,items:r})})).json()).dataset}};var at=require("async_hooks"),y=new at.AsyncLocalStorage;var G=(a=>(a.AccuracyAI="accuracy_ai",a.FactsCompare="facts_compare",a.ContextRecall="context_recall",a.ContextPrecision="context_precision",a.Hallucination="hallucination",a.StringDiff="string_diff",a.Refusal="refusal",a.SqlAst="sql_ast",a))(G||{}),U=(o=>(o.CREATED="CREATED",o.RUNNING="RUNNING",o.SCORING="SCORING",o.SCORING_FAILED="SCORING_FAILED",o.FINISHED="FINISHED",o.FAILED="FAILED",o))(U||{}),T=(n=>(n.OFF="off",n.MONITORING="monitoring",n.EXPERIMENT="experiment",n))(T||{}),K=(e=>(e.CALL="CALL",e.TEXT="TEXT",e))(K||{}),V=(n=>(n.STARTED="STARTED",n.COMPLETED="COMPLETED",n.FAILED="FAILED",n))(V||{}),ct=(n=>(n.DEVELOPMENT="development",n.STAGING="staging",n.PRODUCTION="production",n))(ct||{}),W=(t=>(t[t.MONITORING=1]="MONITORING",t))(W||{}),pt=(e=>(e.Numeric="numeric",e.Classification="classification",e))(pt||{}),j=(e=>(e.Local="local",e.Remote="remote",e))(j||{}),mt=(e=>(e.XML="xml",e.JSON="json",e))(mt||{}),lt=-1,J="<!--hamming_scoring_error-->",ut=(c=>(c.Gray="gray",c.LightGreen="light-green",c.LightBlue="light-blue",c.Amber="amber",c.Purple="purple",c.Pink="pink",c.Green="green",c.PastelGreen="pastel-green",c.Yellow="yellow",c.Blue="blue",c.Red="red",c))(ut||{}),b=(n=>(n.Root="root",n.Call="call",n.CallEvent="call_event",n))(b||{}),z=(n=>(n.Custom="custom",n.Retell="retell",n.Vapi="vapi",n))(z||{}),B=(n=>(n.Started="call_started",n.Ended="call_ended",n.Analyzed="call_analyzed",n))(B||{}),X=(e=>(e.StatusUpdate="status-update",e.EndOfCallReport="end-of-call-report",e))(X||{});async function gt(s,t,e=100){let n=s.entries(),r=Math.min(e,s.length,100),i=Array(r).fill(n).map(async(o,p)=>{for(let[a,u]of o)process.env.NODE_ENV==="development"&&console.log(`Worker ${p} is processing task ${a}`),await t(u),process.env.NODE_ENV==="development"&&console.log(`Worker ${p} has finished task ${a}`)});await Promise.all(i)}var dt=10;function ht(s){return{tracing:{experiment:{itemId:s}}}}var Ht=["string_diff"],Q=class{client;constructor(t){this.client=t}async start(t,e,n){let o=(await(await this.client.fetch(`/experiments/${t.id}/items`,{method:"POST",body:JSON.stringify({datasetItemId:e.id,output:{},metrics:{},sampleId:n})})).json()).item,p=Date.now();return{item:o,startTs:p}}async end(t,e,n={},r=!1){let{item:i,startTs:o}=t,p=Date.now()-o;await this.client.tracing._flush(i.id),await this.client.fetch(`/experiments/${i.experimentId}/items/${i.id}`,{method:"PATCH",body:JSON.stringify({output:e,scores:n,metrics:{durationMs:p},failed:r})})}},D=class{client;items;constructor(t){this.client=t,this.items=new Q(this.client)}async run(t,e){let{dataset:n}=t,r=await this.client.datasets.load(n);this.client.tracing._setMode("experiment");let{name:i=this.generateName(r.name),scoring:o=Ht,metadata:p={},sampling:a}=t,u=a??1;if(u>dt)throw new Error(`The maximum number of samples is ${dt}.`);let m=new Y(this.client,o);await m.initialize();let c=await this.start(i,n,m.getConfig(),p,a),h=`${new URL(this.client.baseURL).origin}/experiments/${c.id}`;try{for(let C=0;C<u;C++)if(t.parallel){let w=async g=>{let I=await this.items.start(c,g,C);try{let f=await y.run(ht(I.item.id),async()=>e(g.input));if(!f||typeof f!="object")throw new Error(`Invalid output: ${f}`);let nt=await m.score(g.input,g.output,f);await this.items.end(I,f,nt)}catch(f){console.error(f);let Tt={error:f instanceof Error?f.message:"Unknown error"};await this.items.end(I,Tt,{},!0)}},v=typeof t.parallel=="number"?t.parallel:void 0;await gt(r.items,w,v)}else for(let w of r.items){let v=await this.items.start(c,w,C);try{let g=await y.run(ht(v.item.id),async()=>await e(w.input));if(!g||typeof g!="object")throw new Error(`Invalid output: ${g}`);let I=await m.score(w.input,w.output,g);await this.items.end(v,g,I)}catch(g){console.error(g);let f={error:g instanceof Error?g.message:"Unknown error"};await this.items.end(v,f,{},!0)}}}catch(C){throw await this.end(c,"FAILED"),C}finally{await this.end(c),console.log("See experiment results at:",h)}return{experimentUrl:h}}async start(t,e,n,r,i){let o="RUNNING";return(await(await this.client.fetch("/experiments",{method:"POST",body:JSON.stringify({name:t,dataset:e,status:o,scoring:n,metadata:r,sampling:i})})).json()).experiment}async end(t,e="FINISHED"){await this.client.fetch(`/experiments/${t.id}`,{method:"PATCH",body:JSON.stringify({status:e})})}generateName(t){return`Experiment for ${t} - ${new Date().toLocaleString()}`}},Y=class{client;standardScoring;customScoring;registeredFunctions=[];initialized=!1;constructor(t,e){this.client=t,this.standardScoring=e.filter(n=>typeof n=="string"),this.customScoring=e.filter(n=>typeof n!="string")}async initialize(){await this.registerScoringFunctions(),this.initialized=!0}getConfig(){if(!this.initialized)throw new Error("ScoringHelper is not initialized");return[...this.standardScoring,...this.registeredFunctions.map(t=>t.registration)]}async score(t,e,n){if(!this.initialized)throw new Error("ScoringHelper is not initialized");let r={},i=this.registeredFunctions.filter(o=>o.scorer.type==="local").map(async o=>{let p=o.scorer;try{r[o.registration.key_name]=await p.scoreFn({input:t,output:n,expected:e})}catch(a){console.error(`Failed to locally run score ${o.name.toLowerCase()}.`,"Note: This error will be displayed in the dashboard. All other scoring will be preserved and displayed accordingly.","Error received:",a),r[o.registration.key_name]={value:-1,reason:`${J}${a.message}`}}});return await Promise.allSettled(i),r}async registerScoringFunctions(){let t=this.customScoring.map(i=>({name:i.name,version:i.version,score_config:i.scoreConfig,execution_config:Ft(i)})),r=(await(await this.client.fetch("/scoring/register-functions",{method:"POST",body:JSON.stringify({scoring:t})})).json()).scoring??[];this.registeredFunctions=this.customScoring.map((i,o)=>({...i,registration:r[o]}))}};function Ft(s){if(s.scorer.type==="remote"){let{prompt:t,variableMappings:e,scoreParser:n}=s.scorer;return{kind:"remote",prompt:t,variableMappings:e,scoreParser:n}}return{kind:"local"}}var Ct=require("lru-cache");function ft(s){let t=s.call.call_id;if(!(!t||typeof t!="string"))return t}function yt(s){let t=s.message.call;if(!t||typeof t!="object")return;let e=t.id;if(!(!e||typeof e!="string"))return e}var S=class{_generationEvent(t){return{kind:"llm",...t}}_retrievalEvent(t){var o,p;let e=a=>typeof a=="string",n=(o=t.results)==null?void 0:o.every(e),r=a=>typeof a=="string"?{pageContent:a,metadata:{}}:a,i=n?(p=t.results)==null?void 0:p.map(r):t.results;return{kind:"vector",...t,results:i}}log(t,e){let n=typeof t=="string"?{[t]:e}:t;this.logEvent(n)}logGeneration(t){var n,r;let e={...t,metadata:{...t.metadata,error:((n=t.metadata)==null?void 0:n.error)||!!((r=t.metadata)!=null&&r.error_message)}};this.log(this._generationEvent(e))}logRetrieval(t){this.log(this._retrievalEvent(t))}},k=class extends S{client;collected={};currentLocalTraceId=0;mode="off";constructor(t){super(),this.client=t}_setMode(t){this.mode=t}nextTraceId(){return this.currentLocalTraceId++}async _flush(t){if(this.mode!=="experiment"){console.warn("Tracing mode must be set to <experiment>!");return}let e=this.collected[t]??[];delete this.collected[t];let n={id:this.nextTraceId(),experimentItemId:t,event:{kind:"root"}},r=[n];for(let i of e)r.push({id:this.nextTraceId(),experimentItemId:t,parentId:n.id,event:i});await this.client.fetch("/traces",{method:"POST",body:JSON.stringify({traces:r})})}_logLiveTrace(t){if(this.mode!=="monitoring"){console.warn("Tracing mode must be set to <monitoring>!");return}this.client._logger.log({type:1,payload:t})}logEvent(t){var n,r;let e=y.getStore();if(this.mode==="experiment"){let i=(r=(n=e==null?void 0:e.tracing)==null?void 0:n.experiment)==null?void 0:r.itemId;if(!i){console.error("Unable to log trace event without experiment item ID.");return}this.collected[i]||(this.collected[i]=[]),this.collected[i].push(t)}else if(this.mode==="monitoring"){let i=this.client.monitoring._getTraceContext(e);if(!i)return;this._logLiveTrace({event:t,...i})}else console.warn("Attempt to send a log trace, but tracing mode is off!")}};var Gt="INVALID_SESSION";function wt(s){return{tracing:{monitoring:{seqId:s}}}}var Z=class extends S{client;runCtx;constructor(t,e){super(),this.client=t,this.runCtx=wt(e)}logEvent(t){let e=this.client.monitoring._getTraceContext(this.runCtx);e&&this.client.tracing._logLiveTrace({event:t,...e})}},A=class{client;sessionId;seqId;input;output;metadata;metrics;status;errorMessage;startTs;itemType;tracing;constructor(t,e,n,r){this.itemType=r,this.client=t,this.sessionId=e,this.seqId=n,this.metrics={},this.tracing=new Z(t,n)}setInput(t){this.input=t}setOutput(t){this.output=t}setMetadata(t){this.metadata=t}end(t=!1,e){this._end(t,e)}_start(){this.startTs=Date.now(),this.status="STARTED"}_end(t=!1,e){this._hasEnded()||(this.metrics.duration_ms=Date.now()-this.startTs,this.status=t?"FAILED":"COMPLETED",this.errorMessage=e,this.client.monitoring._endItem(this._toTrace()))}_hasEnded(){return["COMPLETED","FAILED"].includes(this.status)}_toTrace(){return{session_id:this.sessionId,seq_id:this.seqId,parent_seq_id:void 0,event:{kind:this.itemType==="CALL"?"call":"root",input:this.input,output:this.output,metadata:this.metadata,metrics:this.metrics,status:this.status,error_message:this.errorMessage}}}},N=class{client;state=1;session;monitoringStartOpts;callEvents;constructor(t){this.client=t}start(t){this.monitoringStartOpts=t,this.client._logger.start(),this.client.tracing._setMode("monitoring"),this.state=0,this.callEvents=new Ct.LRUCache({max:1e3,ttl:1e3*60*60*2}),console.log("Monitoring started!")}stop(){this.session=null,this.client.tracing._setMode("off"),this.client._logger.stop(),this.state=1,this.callEvents.clear(),console.log("Monitoring stopped!")}async runItem(t){await this._createSessionIfNotExist();let[e,n]=this._nextSeqId(),r=new A(this.client,e,n,"TEXT");r._start();try{let i=await y.run(wt(r.seqId),async()=>await t(r));return r.output||(i&&i instanceof Object&&!Array.isArray(i)?r.setOutput(i):r.setOutput({response:i})),r._end(),i}catch(i){throw r._end(!0,i.message),i}}async _startItem(t){await this._createSessionIfNotExist();let[e,n]=this._nextSeqId(),r=new A(this.client,e,n,t);return r._start(),r}async startItem(){return this._startItem("TEXT")}async _startCall(){return this._startItem("CALL")}_endItem(t){this.state!==1&&this.client.tracing._logLiveTrace(t)}_getTraceContext(t){var i,o;if(this.state===1)return null;if(!this.session)throw Error("Monitoring not started");let[e,n]=this._nextSeqId(),r=(o=(i=t==null?void 0:t.tracing)==null?void 0:i.monitoring)==null?void 0:o.seqId;return{session_id:e,seq_id:n,parent_seq_id:r}}async callEvent(t,e,n){switch(t){case"custom":throw Error("Custom call provider not implemented!");case"retell":await this.handleRetellCallEvent(e,n);break;case"vapi":await this.handleVapiCallEvent(e,n);break;default:throw Error(`Unsupported call provider: ${t}`)}}async handleRetellCallEvent(t,e={}){let n=ft(t);if(!n)throw Error("call_id is missing");let r;t.event==="call_started"?(r=await this._startCall(),r.tracing.log({kind:"call_event",event:t}),this.callEvents.set(n,r)):t.event==="call_ended"?(r=this.callEvents.get(n),r||(console.warn(`Missing call_started event for id: ${n}`),r=await this._startCall(),this.callEvents.set(n,r)),r.tracing.log({kind:"call_event",event:t}),r.setInput({provider:"retell"}),r.setMetadata(e),r.setOutput(t.call),r.end()):t.event==="call_analyzed"&&(r=this.callEvents.get(n),r?r.tracing.log({kind:"call_event",event:t}):(console.warn(`Missing call_started event for id: ${n}`),r=await this._startCall(),r.tracing.log({kind:"call_event",event:t}),r.end()))}async handleVapiCallEvent(t,e={}){if(t.message.type!=="status-update"&&t.message.type!=="end-of-call-report")return;let n=yt(t);if(!n)throw Error("call ID is missing");let i=await(async()=>{let o=this.callEvents.get(n);return o||(o=await this._startCall(),this.callEvents.set(n,o)),o})();switch(t.message.type){case"status-update":i.tracing.log({kind:"call_event",event:t});break;case"end-of-call-report":i.setInput({provider:"vapi"}),i.setMetadata(e),i.setOutput(t.message),i.end();break;default:throw Error(`Unsupported Vapi call event type: ${t.message.type}`)}}_nextSeqId(){if(this.state===1)return[Gt,0];if(!this.session)throw Error("Monitoring not started");return this.session.seqId+=1,[this.session.id,this.session.seqId]}async _createSessionIfNotExist(){var r;if(this.state===1||this.session)return;let t=((r=this.monitoringStartOpts)==null?void 0:r.environment)??process.env.NODE_ENV,n=await(await this.client.fetch("/sessions",{method:"POST",body:JSON.stringify({metadata:t?{environment:t}:{}})})).json();this.session={id:n.id,seqId:0}}};var Et=require("openai/streaming.mjs");var tt=class{constructor(t){this.client=t}openai;async load(){if(this.openai)return this.openai;if(!this.client.openaiApiKey)throw new Error("OpenAI API key not set. Initialize the Hamming client with an OpenAI API key.");let t=await import("openai");return this.openai=new t.OpenAI({apiKey:this.client.openaiApiKey}),this.openai}async createChatCompletion(t,e){if(!t.content)throw new Error("Prompt content not set");let r=new d(t.content).compile(e||{}),i=await this.load(),o=It(r);return await this.client.monitoring.runItem(async a=>{a.setInput(o),a.setMetadata({sdk:{type:"openai_prompt",stream:!1,prompt:{slug:t.slug},variables:e}});let u={model:o.model,stream:!1,temperature:o.temperature??void 0,max_tokens:o.max_tokens??void 0,n:o.n??void 0,seed:o.seed??void 0};try{let m=await i.chat.completions.create({...o,stream:!1});return a.tracing.logGeneration({input:JSON.stringify(o),output:JSON.stringify(m),metadata:{...u,usage:m.usage}}),a.setOutput(m),m}catch(m){throw a.tracing.logGeneration({input:JSON.stringify(o),metadata:{...u,error:!0,error_message:m.message}}),m}})}async createChatCompletionStream(t,e){if(!t.content)throw new Error("Prompt content not set");let r=new d(t.content).compile(e||{}),i=await this.load(),o=It(r),p=await this.client.monitoring.startItem();p.setInput(o),p.setMetadata({sdk:{type:"openai_prompt",stream:!0,prompt:{slug:t.slug},variables:e}});let a={model:o.model,stream:!0,temperature:o.temperature??void 0,max_tokens:o.max_tokens??void 0,n:o.n??void 0,seed:o.seed??void 0};try{let u=await i.chat.completions.create({...o,stream:!0});return new Et.Stream(async function*(){let c=[];for await(let h of u)c.push(h),yield h;let l=c.length>0?c[c.length-1]:null;p.tracing.logGeneration({input:JSON.stringify(o),output:JSON.stringify({chunks:c}),metadata:{...a,usage:l==null?void 0:l.usage}}),p.setOutput({chunks:c}),p.end()},u.controller)}catch(u){throw p.tracing.logGeneration({input:JSON.stringify(o),metadata:{...a,error:!0,error_message:u.message}}),p.end(!0,u.message),u}finally{}}};function It(s){return{model:s.languageModel,messages:s.chatMessages.map(t=>Ut(t)),temperature:s.promptSettings.temperature,max_tokens:s.promptSettings.maxTokens,top_p:s.promptSettings.topP,frequency_penalty:s.promptSettings.frequencyPenalty,presence_penalty:s.promptSettings.presencePenalty,tool_choice:s.promptSettings.toolChoice&&s.tools?Kt(s.promptSettings.toolChoice):void 0,tools:s.tools?JSON.parse(s.tools):void 0}}function Ut(s){switch(s.role){case"system":return{role:"system",content:s.content};case"user":return{role:"user",content:s.content};case"assistant":return{role:"assistant",content:s.content};default:throw new Error(`Unsupported message role: ${s.role}`)}}function Kt(s){switch(s.choice){case"none":return"none";case"auto":return"auto";case"function":return{type:"function",function:{name:s.functionName}};default:throw new Error(`Unsupported tool choice: ${s.choice}`)}}var vt=tt;var L=class{constructor(t){this.client=t}async list(t){let e="/prompts";return t&&(e+=`?label=${t}`),(await(await this.client.fetch(e)).json()).prompts}async get(t,e,n){let r=`/prompts/${t}`;return e&&(r+=`?label=${e}`),n&&(r+=`&version=${n}`),(await(await this.client.fetch(r)).json()).prompt}};var xt=["apiKey","baseURL","openaiApiKey","anthropicApiKey","bedrock"],et=class extends P{openaiApiKey;anthropicApiKey;bedrock;constructor(t){let e=Object.keys(t).filter(n=>!xt.includes(n));e.length>0&&console.warn(`WARNING: Unexpected config keys found: ${e.join(", ")}. Valid config keys are: ${xt.join(", ")}. The unexpected keys will be ignored.`),super({apiKey:t.apiKey,baseURL:t.baseURL??"https://app.hamming.ai/api/rest"}),this.openaiApiKey=t.openaiApiKey,this.anthropicApiKey=t.anthropicApiKey,this.bedrock=t.bedrock}experiments=new D(this);datasets=new _(this);tracing=new k(this);monitoring=new N(this);prompts=new L(this);openai=new vt(this);anthropic=new it(this);anthropicBedrock=new ot(this);_logger=new O(this)};0&&(module.exports={CallProvider,EventKind,ExperimentStatus,FunctionType,Hamming,LabelColor,LogMessageType,MonitoringItemStatus,MonitoringItemType,PromptTemplate,RetellCallEventType,ScoreParserType,ScoreType,ScorerExecutionType,ScoringErrorPrefix,ScoringErrorValue,SessionEnvironment,TracingMode,VapiCallEventType});
//# sourceMappingURL=index.cjs.map