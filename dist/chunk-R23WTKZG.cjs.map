{"version":3,"sources":["../src/httpClient.ts"],"names":["HttpClient","opts","__publicField","baseURL","input","init","maxRetries","retryDelay","url","lastError","currentRetryDelay","attempt","response","errorMessage","error","ms","resolve","status","statusText","headers","existingHeaders","retryAfter","retryDelayMs","date"],"mappings":"wKAgCO,IAAMA,EAAN,KAAiB,CAItB,YAAYC,EAAyB,CAHrCC,EAAA,eACAA,EAAA,gBAGE,KAAK,OAASD,EAAK,OACnB,KAAK,QAAU,KAAK,gBAAgBA,EAAK,OAAO,CAClD,CAOQ,gBAAgBE,EAAyB,CAC/C,OAAOA,EAAQ,KAAK,EAAE,QAAQ,MAAO,EAAE,CACzC,CAEA,MAAM,MACJC,EACAC,EACAC,EAAqB,EACrBC,EAAqB,IACF,CACnB,IAAMC,EAAM,KAAK,QAAUJ,EAEvBK,EAA0B,KAC1BC,EAAoBH,EAExB,QAASI,EAAU,EAAGA,EAAUL,EAAYK,IAC1C,GAAI,CACF,IAAMC,EAAW,MAAM,KAAK,aAAaJ,EAAKH,CAAI,EAGlD,GAAIO,EAAS,GAAI,OAAOA,EAGxB,IAAMC,EAAe,KAAK,qBAAqBD,EAAUJ,CAAG,EAI5D,GAHAC,EAAY,IAAI,MAAMI,CAAY,EAG9B,KAAK,kBAAkBD,CAAQ,EAAG,MAGtC,GAAI,KAAK,YAAYA,CAAQ,EAC3B,MAAM,KAAK,aAAaA,EAAUF,CAAiB,EACnDA,GAAqB,MAGrB,OAAM,IAAI,MAAMG,CAAY,CAEhC,OAASC,EAAO,CAId,GAHAL,EAAYK,EAGR,CAAC,KAAK,eAAeA,CAAK,EAAG,MACjC,MAAM,KAAK,MAAMJ,CAAiB,EAClCA,GAAqB,CACvB,CAEF,MAAMD,CACR,CAEQ,kBAAkBG,EAA6B,CACrD,MAAO,CAAC,IAAc,IAAW,IAAW,GAAW,EAAE,SACvDA,EAAS,MACX,CACF,CAEQ,MAAMG,EAAY,CACxB,OAAO,IAAI,QAASC,GAAY,WAAWA,EAASD,CAAE,CAAC,CACzD,CAEQ,YAAYH,EAA6B,CAC/C,OACEA,EAAS,SAAW,KACpBA,EAAS,QAAU,GAEvB,CAGQ,eAAeE,EAAqB,CAC1C,OAAOA,aAAiB,SAC1B,CAGQ,qBAAqBF,EAAoBJ,EAAa,CAC5D,IAAMS,EAASL,EAAS,OAClBM,EAAaN,EAAS,WAExBC,EAAe,8BAA8BI,CAAM,IAAIC,CAAU,oBAAoBV,CAAG,IAE5F,OAAIS,IAAW,IACbJ,EAAe,4CAA4C,KAAK,OAAO,MACrE,EACF,CAAC,kEACQI,IAAW,IACpBJ,EAAe,mDAAmDL,CAAG,IAC5DS,IAAW,IACpBJ,EAAe,wCAAwCL,CAAG,uBACjDS,IAAW,IACpBJ,EAAe,8KACNI,GAAU,MACnBJ,EAAe,qEAAqEL,CAAG,mFAElFK,CACT,CAEA,MAAc,aACZL,EACAH,EACmB,CACnB,IAAMc,EAAU,KAAK,cAAcd,GAAM,OAAO,EAEhD,OADiB,MAAM,MAAMG,EAAK,CAAE,GAAGH,EAAM,QAAAc,CAAQ,CAAC,CAExD,CAEQ,cAAcC,EAA4C,CAChE,IAAMD,EAAuB,CAC3B,GAAGC,EACH,cAAe,UAAU,KAAK,MAAM,EACtC,EACA,OAAI,CAACA,GAAmB,EAAE,iBAAkBA,MAC1CD,EAAQ,cAAc,EAAI,oBAErBA,CACT,CAQA,MAAc,aACZP,EACAL,EACe,CACf,IAAMc,EAAaT,EAAS,QAAQ,IAAI,aAAa,EAC/CU,EAAeD,EACjB,KAAK,8BAA8BA,EAAYd,CAAU,EACzDA,EACJ,MAAM,KAAK,MAAMe,CAAY,CAC/B,CAEQ,8BACND,EACAd,EACQ,CACR,GAAI,SAASc,EAAY,EAAE,EACzB,OAAO,SAASA,EAAY,EAAE,EAAI,IAGpC,IAAME,EAAO,IAAI,KAAKF,CAAU,EAChC,OAAK,MAAME,EAAK,QAAQ,CAAC,EAGlBhB,EAFEgB,EAAK,QAAQ,EAAI,KAAK,IAAI,CAGrC,CACF","sourcesContent":["const OK = 200;\nconst BAD_REQUEST = 400;\nconst UNAUTHORIZED = 401;\nconst FORBIDDEN = 403;\nconst NOT_FOUND = 404;\nconst TOO_MANY_REQUESTS = 429;\nconst INTERNAL_SERVER_ERROR = 500;\nconst BAD_GATEWAY = 502;\nconst SERVICE_UNAVAILABLE = 503;\nconst GATEWAY_TIMEOUT = 504;\n\ninterface HttpClientOptions {\n  apiKey: string;\n  baseURL: string;\n}\n\nconst DEFAULT_RETRY_DELAY = 1000;\nconst DEFAULT_MAX_RETRIES = 3;\n\n/**\n * The HttpClient provides methods to perform HTTP requests.\n * The `fetch` method is used to make a request to a specified endpoint.\n * It includes retry logic for transient errors, where it will retry the request\n * according to the `maxRetries` and `retryDelay` parameters.\n * For non-transient errors, it will fail fast and not retry the request.\n * @param input - The endpoint to which the request will be made.\n * @param init - The request options.\n * @param maxRetries - The maximum number of retries for the request.\n * @param retryDelay - The delay between retries.\n * @returns A promise that resolves to the response of the request, or rejects\n *          with an error if the request fails or all retries are exhausted.\n */\nexport class HttpClient {\n  apiKey: string;\n  baseURL: string;\n\n  constructor(opts: HttpClientOptions) {\n    this.apiKey = opts.apiKey;\n    this.baseURL = this.sanitizeBaseUrl(opts.baseURL);\n  }\n\n  /**\n   * Sanitizes the base URL by trimming whitespace and removing trailing slashes.\n   * @param baseURL - The base URL to sanitize.\n   * @returns The sanitized base URL.\n   */\n  private sanitizeBaseUrl(baseURL: string): string {\n    return baseURL.trim().replace(/\\/$/, \"\");\n  }\n\n  async fetch(\n    input: string,\n    init?: RequestInit | undefined,\n    maxRetries: number = DEFAULT_MAX_RETRIES,\n    retryDelay: number = DEFAULT_RETRY_DELAY,\n  ): Promise<Response> {\n    const url = this.baseURL + input;\n\n    let lastError: Error | null = null;\n    let currentRetryDelay = retryDelay;\n\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\n      try {\n        const response = await this.attemptFetch(url, init);\n\n        // Check for OK response\n        if (response.ok) return response;\n\n        // If not ok, then generate an error message\n        const errorMessage = this.generateErrorMessage(response, url);\n        lastError = new Error(errorMessage);\n\n        // Fail fast for non-transient errors\n        if (this.nonTransientError(response)) break;\n\n        // Retry logic for transient errors\n        if (this.shouldRetry(response)) {\n          await this.waitForRetry(response, currentRetryDelay);\n          currentRetryDelay *= 2;\n        } else {\n          // For other errors, throw an error\n          throw new Error(errorMessage);\n        }\n      } catch (error) {\n        lastError = error as Error;\n\n        // Fail fast for a non-transient error\n        if (!this.isNetworkError(error)) break;\n        await this.delay(currentRetryDelay);\n        currentRetryDelay *= 2;\n      }\n    }\n    throw lastError;\n  }\n\n  private nonTransientError(response: Response): boolean {\n    return [UNAUTHORIZED, FORBIDDEN, NOT_FOUND, BAD_REQUEST].includes(\n      response.status,\n    );\n  }\n\n  private delay(ms: number) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  private shouldRetry(response: Response): boolean {\n    return (\n      response.status === TOO_MANY_REQUESTS ||\n      response.status >= INTERNAL_SERVER_ERROR\n    );\n  }\n\n  // Network error check\n  private isNetworkError(error: any): boolean {\n    return error instanceof TypeError;\n  }\n\n  // This could be redundant if we sent the correct error message from the server\n  private generateErrorMessage(response: Response, url: string) {\n    const status = response.status;\n    const statusText = response.statusText;\n\n    let errorMessage = `Request failed with status ${status} ${statusText} while accessing ${url}.`;\n\n    if (status === UNAUTHORIZED) {\n      errorMessage = `UNAUTHORIZED: Invalid API key ending in '${this.apiKey.slice(\n        -4,\n      )}'. Visit https://app.hamming.ai/settings to see valid API keys.`;\n    } else if (status === FORBIDDEN) {\n      errorMessage = `FORBIDDEN: You do not have permission to access ${url}.`;\n    } else if (status === NOT_FOUND) {\n      errorMessage = `NOT FOUND: The requested resource at ${url} could not be found.`;\n    } else if (status === TOO_MANY_REQUESTS) {\n      errorMessage = `TOO MANY REQUESTS: You are being rate limited. Please wait before making additional requests. If the issue persists, feel free to email us at founders@hamming.ai for help.`;\n    } else if (status >= 500) {\n      errorMessage = `SERVER ERROR: There was a problem with the server while accessing ${url}. If the issue persists, feel free to email us at founders@hamming.ai for help.`;\n    }\n    return errorMessage;\n  }\n\n  private async attemptFetch(\n    url: string,\n    init?: RequestInit,\n  ): Promise<Response> {\n    const headers = this.createHeaders(init?.headers);\n    const response = await fetch(url, { ...init, headers });\n    return response;\n  }\n\n  private createHeaders(existingHeaders?: HeadersInit): HeadersInit {\n    const headers: HeadersInit = {\n      ...existingHeaders,\n      authorization: `Bearer ${this.apiKey}`,\n    };\n    if (!existingHeaders || !(\"content-type\" in existingHeaders)) {\n      headers[\"content-type\"] = \"application/json\";\n    }\n    return headers;\n  }\n\n  /**\n   * If the 'Retry-After' header is present in the response, it indicates how long\n   * the client should wait before making a new request.\n   *\n   * If not, we use the retryDelay parameter to determine how long to wait.\n   */\n  private async waitForRetry(\n    response: Response,\n    retryDelay: number,\n  ): Promise<void> {\n    const retryAfter = response.headers.get(\"Retry-After\");\n    const retryDelayMs = retryAfter\n      ? this.calculateRetryDelayForHeaders(retryAfter, retryDelay)\n      : retryDelay;\n    await this.delay(retryDelayMs);\n  }\n\n  private calculateRetryDelayForHeaders(\n    retryAfter: string,\n    retryDelay: number,\n  ): number {\n    if (parseInt(retryAfter, 10)) {\n      return parseInt(retryAfter, 10) * 1000;\n    }\n    // If Retry-After is an HTTP-date, calculate delay until that date\n    const date = new Date(retryAfter);\n    if (!isNaN(date.getTime())) {\n      return date.getTime() - Date.now();\n    }\n    return retryDelay;\n  }\n}\n"]}