{"version":3,"sources":["../src/resources/tracing.ts"],"sourcesContent":["import { asyncRunContext } from \"../asyncStorage\";\nimport type { Hamming } from \"../client\";\nimport {\n  Document,\n  GenerationParams,\n  ITracing,\n  LogMessageType,\n  MonitoringTrace,\n  RetrievalParams,\n  Trace,\n  TraceEvent,\n  TracingMode,\n} from \"../types\";\n\nexport class Tracing implements ITracing {\n  private client: Hamming;\n  private collected: Record<string, TraceEvent[]> = {};\n  private currentLocalTraceId: number = 0;\n\n  private mode: TracingMode = TracingMode.OFF;\n\n  constructor(client: Hamming) {\n    this.client = client;\n  }\n\n  _setMode(mode: TracingMode) {\n    this.mode = mode;\n  }\n\n  private nextTraceId(): number {\n    return this.currentLocalTraceId++;\n  }\n\n  async _flush(experimentItemId: string) {\n    if (this.mode !== TracingMode.EXPERIMENT) {\n      console.warn(`Tracing mode must be set to <experiment>!`);\n      return;\n    }\n\n    const events = this.collected[experimentItemId] ?? [];\n    delete this.collected[experimentItemId];\n\n    const rootTrace: Trace = {\n      id: this.nextTraceId(),\n      experimentItemId,\n      event: { kind: \"root\" },\n    };\n\n    const traces: Trace[] = [rootTrace];\n\n    for (const event of events) {\n      traces.push({\n        id: this.nextTraceId(),\n        experimentItemId,\n        parentId: rootTrace.id,\n        event,\n      });\n    }\n\n    await this.client.fetch(`/traces`, {\n      method: \"POST\",\n      body: JSON.stringify({\n        traces,\n      }),\n    });\n  }\n\n  private _generationEvent(params: GenerationParams): TraceEvent {\n    return {\n      kind: \"llm\",\n      ...params,\n    };\n  }\n\n  private _retrievalEvent(params: RetrievalParams): TraceEvent {\n    const isString = (item: any) => typeof item === \"string\";\n    const hasStringResults = params.results?.every(isString);\n    const normalizeResult = (result: string | Document): Document => {\n      if (typeof result === \"string\") {\n        return { pageContent: result, metadata: {} };\n      }\n      return result;\n    };\n\n    const results = hasStringResults\n      ? params.results?.map(normalizeResult)\n      : params.results;\n\n    return {\n      kind: \"vector\",\n      ...params,\n      results,\n    };\n  }\n\n  _logLiveTrace(trace: MonitoringTrace) {\n    if (this.mode !== TracingMode.MONITORING) {\n      console.warn(`Tracing mode must be set to <monitoring>!`);\n      return;\n    }\n\n    this.client._logger.log({\n      type: LogMessageType.MONITORING,\n      payload: trace,\n    });\n  }\n\n  log(key: string, value: unknown): void;\n  log(trace: TraceEvent): void;\n  log(keyOrTrace: string | TraceEvent, value?: unknown): void {\n    const event = (() => {\n      const isKeyValue = typeof keyOrTrace === \"string\";\n      if (isKeyValue) {\n        const key = keyOrTrace as string;\n        const event: TraceEvent = { [key]: value };\n        return event;\n      } else {\n        const event = keyOrTrace as TraceEvent;\n        return event;\n      }\n    })();\n\n    if (this.mode === TracingMode.EXPERIMENT) {\n      const runCtx = asyncRunContext.getStore();\n      const itemId = runCtx?.tracing?.experiment?.itemId;\n\n      if (!itemId) {\n        console.error(\"Unable to log trace event without experiment item ID.\");\n        return;\n      }\n      if (!this.collected[itemId]) {\n        this.collected[itemId] = [];\n      }\n      this.collected[itemId].push(event);\n    } else if (this.mode === TracingMode.MONITORING) {\n      const trace = this.client.monitoring._getTraceContext();\n      this._logLiveTrace({\n        event,\n        ...trace,\n      });\n    } else {\n      console.warn(\"Attempt to send a log trace, but tracing mode is off!\");\n    }\n  }\n\n  logGeneration(params: GenerationParams): void {\n    this.log(this._generationEvent(params));\n  }\n\n  logRetrieval(params: RetrievalParams): void {\n    this.log(this._retrievalEvent(params));\n  }\n}\n"],"mappings":"2EAcO,IAAMA,EAAN,KAAkC,CAOvC,YAAYC,EAAiB,CAN7BC,EAAA,KAAQ,UACRA,EAAA,KAAQ,YAA0C,CAAC,GACnDA,EAAA,KAAQ,sBAA8B,GAEtCA,EAAA,KAAQ,cAGN,KAAK,OAASD,CAChB,CAEA,SAASE,EAAmB,CAC1B,KAAK,KAAOA,CACd,CAEQ,aAAsB,CAC5B,OAAO,KAAK,qBACd,CAEA,MAAM,OAAOC,EAA0B,CACrC,GAAI,KAAK,oBAAiC,CACxC,QAAQ,KAAK,2CAA2C,EACxD,MACF,CAEA,IAAMC,EAAS,KAAK,UAAUD,CAAgB,GAAK,CAAC,EACpD,OAAO,KAAK,UAAUA,CAAgB,EAEtC,IAAME,EAAmB,CACvB,GAAI,KAAK,YAAY,EACrB,iBAAAF,EACA,MAAO,CAAE,KAAM,MAAO,CACxB,EAEMG,EAAkB,CAACD,CAAS,EAElC,QAAWE,KAASH,EAClBE,EAAO,KAAK,CACV,GAAI,KAAK,YAAY,EACrB,iBAAAH,EACA,SAAUE,EAAU,GACpB,MAAAE,CACF,CAAC,EAGH,MAAM,KAAK,OAAO,MAAM,UAAW,CACjC,OAAQ,OACR,KAAM,KAAK,UAAU,CACnB,OAAAD,CACF,CAAC,CACH,CAAC,CACH,CAEQ,iBAAiBE,EAAsC,CAC7D,MAAO,CACL,KAAM,MACN,GAAGA,CACL,CACF,CAEQ,gBAAgBA,EAAqC,CAC3D,IAAMC,EAAYC,GAAc,OAAOA,GAAS,SAC1CC,EAAmBH,EAAO,SAAS,MAAMC,CAAQ,EACjDG,EAAmBC,GACnB,OAAOA,GAAW,SACb,CAAE,YAAaA,EAAQ,SAAU,CAAC,CAAE,EAEtCA,EAGHC,EAAUH,EACZH,EAAO,SAAS,IAAII,CAAe,EACnCJ,EAAO,QAEX,MAAO,CACL,KAAM,SACN,GAAGA,EACH,QAAAM,CACF,CACF,CAEA,cAAcC,EAAwB,CACpC,GAAI,KAAK,oBAAiC,CACxC,QAAQ,KAAK,2CAA2C,EACxD,MACF,CAEA,KAAK,OAAO,QAAQ,IAAI,CACtB,OACA,QAASA,CACX,CAAC,CACH,CAIA,IAAIC,EAAiCC,EAAuB,CAC1D,IAAMV,EACe,OAAOS,GAAe,SAGb,CAAE,CADhBA,CACoB,EAAGC,CAAM,EAG3BD,EAKlB,GAAI,KAAK,oBAAiC,CAExC,IAAME,EADSC,EAAgB,SAAS,GACjB,SAAS,YAAY,OAE5C,GAAI,CAACD,EAAQ,CACX,QAAQ,MAAM,uDAAuD,EACrE,MACF,CACK,KAAK,UAAUA,CAAM,IACxB,KAAK,UAAUA,CAAM,EAAI,CAAC,GAE5B,KAAK,UAAUA,CAAM,EAAE,KAAKX,CAAK,CACnC,SAAW,KAAK,oBAAiC,CAC/C,IAAMQ,EAAQ,KAAK,OAAO,WAAW,iBAAiB,EACtD,KAAK,cAAc,CACjB,MAAAR,EACA,GAAGQ,CACL,CAAC,CACH,MACE,QAAQ,KAAK,uDAAuD,CAExE,CAEA,cAAcP,EAAgC,CAC5C,KAAK,IAAI,KAAK,iBAAiBA,CAAM,CAAC,CACxC,CAEA,aAAaA,EAA+B,CAC1C,KAAK,IAAI,KAAK,gBAAgBA,CAAM,CAAC,CACvC,CACF","names":["Tracing","client","__publicField","mode","experimentItemId","events","rootTrace","traces","event","params","isString","item","hasStringResults","normalizeResult","result","results","trace","keyOrTrace","value","itemId","asyncRunContext"]}