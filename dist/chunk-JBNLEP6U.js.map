{"version":3,"sources":["../src/logger.ts"],"sourcesContent":["import type { Hamming } from \"./index\";\nimport { LogMessage } from \"./types\";\nimport { ManualResetEvent } from \"./utils/manualResetEvent\";\n\nconst LOG_BATCH_SIZE = 512;\n\nexport class Logger {\n  private client: Hamming;\n\n  private queue: LogMessage[] = [];\n  private stopped: boolean = false;\n  private queueHasMessages = new ManualResetEvent();\n\n  constructor(client: Hamming) {\n    this.client = client;\n  }\n\n  log(message: LogMessage): void {\n    this.queue.push(message);\n    this.queueHasMessages.set();\n  }\n\n  async start(): Promise<void> {\n    console.log(\"Starting logger thread..\");\n    while (!this.stopped) {\n      await this.queueHasMessages.wait();\n      await this._processQueue();\n    }\n    await this._processQueue();\n    console.log(\"Logger thread exited!\");\n  }\n\n  stop(): void {\n    console.log(\"Waiting for logger thread to exit..\");\n    this.stopped = true;\n  }\n\n  private _drainQueue(): LogMessage[] {\n    const batchSize = Math.min(this.queue.length, LOG_BATCH_SIZE);\n    const drainedMessages = this.queue.splice(0, batchSize);\n    return drainedMessages;\n  }\n\n  private async _processQueue(): Promise<void> {\n    const messages = this._drainQueue();\n    await this._publish(messages);\n    // TODO: test and set\n    if (this.queue.length === 0) {\n      this.queueHasMessages.reset();\n    }\n  }\n\n  private async _publish(msgs: LogMessage[]): Promise<void> {\n    if (msgs.length === 0) {\n      return;\n    }\n    if (process.env.NODE_ENV === \"development\") {\n      console.log(`Publishing ${msgs.length} message(s)..`);\n    }\n    try {\n      await this.client.fetch(\"/logs\", {\n        method: \"POST\",\n        body: JSON.stringify({\n          logs: msgs.map((msg) => ({\n            ...msg,\n            payload: {\n              ...msg.payload,\n              session_id: msg.payload?.session_id,\n              seq_id: msg.payload?.seq_id,\n              parent_seq_id: msg.payload?.parent_seq_id,\n            },\n          })),\n        }),\n      });\n      if (process.env.NODE_ENV === \"development\") {\n        console.log(`Published ${msgs.length} messages!`);\n      }\n    } catch (e) {\n      console.error(`Failed to publish messages: ${e}`);\n    }\n  }\n}\n"],"mappings":"gFAIA,IAAMA,EAAiB,IAEVC,EAAN,KAAa,CAOlB,YAAYC,EAAiB,CAN7BC,EAAA,KAAQ,UAERA,EAAA,KAAQ,QAAsB,CAAC,GAC/BA,EAAA,KAAQ,UAAmB,IAC3BA,EAAA,KAAQ,mBAAmB,IAAIC,GAG7B,KAAK,OAASF,CAChB,CAEA,IAAIG,EAA2B,CAC7B,KAAK,MAAM,KAAKA,CAAO,EACvB,KAAK,iBAAiB,IAAI,CAC5B,CAEA,MAAM,OAAuB,CAE3B,IADA,QAAQ,IAAI,0BAA0B,EAC/B,CAAC,KAAK,SACX,MAAM,KAAK,iBAAiB,KAAK,EACjC,MAAM,KAAK,cAAc,EAE3B,MAAM,KAAK,cAAc,EACzB,QAAQ,IAAI,uBAAuB,CACrC,CAEA,MAAa,CACX,QAAQ,IAAI,qCAAqC,EACjD,KAAK,QAAU,EACjB,CAEQ,aAA4B,CAClC,IAAMC,EAAY,KAAK,IAAI,KAAK,MAAM,OAAQN,CAAc,EAE5D,OADwB,KAAK,MAAM,OAAO,EAAGM,CAAS,CAExD,CAEA,MAAc,eAA+B,CAC3C,IAAMC,EAAW,KAAK,YAAY,EAClC,MAAM,KAAK,SAASA,CAAQ,EAExB,KAAK,MAAM,SAAW,GACxB,KAAK,iBAAiB,MAAM,CAEhC,CAEA,MAAc,SAASC,EAAmC,CACxD,GAAIA,EAAK,SAAW,EAGpB,CAAI,QAAQ,IAAI,WAAa,eAC3B,QAAQ,IAAI,cAAcA,EAAK,MAAM,eAAe,EAEtD,GAAI,CACF,MAAM,KAAK,OAAO,MAAM,QAAS,CAC/B,OAAQ,OACR,KAAM,KAAK,UAAU,CACnB,KAAMA,EAAK,IAAKC,IAAS,CACvB,GAAGA,EACH,QAAS,CACP,GAAGA,EAAI,QACP,WAAYA,EAAI,SAAS,WACzB,OAAQA,EAAI,SAAS,OACrB,cAAeA,EAAI,SAAS,aAC9B,CACF,EAAE,CACJ,CAAC,CACH,CAAC,EACG,QAAQ,IAAI,WAAa,eAC3B,QAAQ,IAAI,aAAaD,EAAK,MAAM,YAAY,CAEpD,OAASE,EAAG,CACV,QAAQ,MAAM,+BAA+BA,CAAC,EAAE,CAClD,EACF,CACF","names":["LOG_BATCH_SIZE","Logger","client","__publicField","ManualResetEvent","message","batchSize","messages","msgs","msg","e"]}